__NUXT_JSONP__("/post/907", (function(a,b,c){return {data:[{article:{cid:907,title:"浏览器机制之js事件循环",slug:"907",created:1598282460,modified:1598617946,text:"\u003C!--markdown--\u003E![2020-08-24T14:58:17.png][1]\r\n\r\n## 引言\r\n\r\n总所周知，js是单线程的。单线程意味着，js代码在执行的任何时候，都只有一个主线程来处理所有的任务（为了避免多线程可能产生的诸多问题，直接阉割多线程的可能性）。然而，随着硬件设备的快速发展，网页要做的事情会变得越来越多。人们慢慢意识到，不能让单线程限制了js的效率，然后web worker便应运而生。\r\n\r\n## 栈，堆，队列\r\n\r\n![2020-08-24T14:58:35.png][2]\r\n\r\n基本数据结构知识略过~\r\n\r\n讲讲它们在js语言层面的应用。\r\n\r\n执行栈：函数调用形成了一个由若干帧（执行上下文）组成的栈。\r\n\r\n消息队列：一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。\r\n\r\n\u003E 在 事件循环 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\r\n\u003E 函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。\r\n\r\n## 任务队列\r\n\r\n在js事件循环机制中，存在多种任务队列，它们可分为宏任务（macro-task）和微任务（micro-task）两种。\r\n\r\n- 宏任务包括：setTimeout、setInterval、I\u002FO、UI rendering\r\n- 微任务包括：process.nextTick、Promise、Object.observe（已废弃）、MutationObserver（html5新特性）\r\n\r\n## 事件循环\r\n\r\n![2020-08-24T14:58:17.png][1]\r\n\r\n如上图所示，事件循环就是在主线程清空执行上下文栈后空闲之时，先去微任务队列中读取待执行程序，并装载到主线程中。如果没有内容（各类微任务队列都清空），则将去宏任务队列中寻找。如此往复，周而复始，直至结束。\r\n\r\n## 参考文档\r\n\r\n[并发模型与事件循环-MDN][3]\r\n[详解JavaScript中的Event Loop（事件循环）机制-知乎][4]\r\n[JS事件循环机制（event loop）之宏任务\u002F微任务-掘金][5]\r\n[JavaScript 事件循环机制-掘金][6]\r\n\r\n\r\n  [1]: http:\u002F\u002Fblog.cdn.thinkmoon.cn\u002Fblog\u002Ftypecho\u002F2020-08-24T14:58:17.png\r\n  [2]: http:\u002F\u002Fblog.cdn.thinkmoon.cn\u002Fblog\u002Ftypecho\u002F2020-08-24T14:58:35.png\r\n  [3]: https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FJavaScript\u002FEventLoop\r\n  [4]: https:\u002F\u002Fzhuanlan.zhihu.com\u002Fp\u002F33058983\r\n  [5]: https:\u002F\u002Fjuejin.im\u002Fpost\u002F6844903638238756878\r\n  [6]: https:\u002F\u002Fjuejin.im\u002Fpost\u002F6844903634816204813",order:b,authorId:c,type:"post",status:"publish",commentsNum:c,allowComment:a,allowPing:a,allowFeed:a,parent:b,views:558,likes:3}}],fetch:{},mutations:void 0}}("1",0,1)));