__NUXT_JSONP__("/post/519", (function(a,b){return {data:[{article:{cid:519,title:"写一个图类",slug:"519",created:1508027280,modified:1575727660,text:"\u003C!--markdown--\u003E说到交通网路的模拟化表示，那就不得不用到数据结构中的图。想必这应该是最方便形象的表示方法了把。 \r\n## 图的概念 \r\n\u003E 图是由顶点集合及顶点之间关系的集合组成的一种数据结构，Graph = （V，E）。\r\n其中顶点集合V = { x | x ∈ 某个数据对象集}是个有穷非空集合。E = { \u003Cx, y\u003E | x , y ∈ V && Path( x , y )} ，即边集。\r\n\r\n## 我所知的图的存储结构 \r\n### 邻接矩阵表示 \r\n邻接矩阵的表示，首先将所有的顶点信息组成一个表。然后利用一个矩阵来表示各顶点之间的相邻关系，称之为邻接矩阵。 \r\n\r\n### 邻接表表示 \r\n在第i行的单链表中，各节点（或称边节点）分别存放与同一个顶点Vi关联的各条边。各个节点配有其标识（及对应的顶点）和权值（若为有权图）以及指向另一个边节点的指针。 \r\n\r\n### *邻接多重表表示 \r\n邻接多重表的表示，主要一处理图的边为主（为什么会有这个需求？在什么情况会用到？），要求每条边处理一次的实际应用中特别有用（比如？）。它的主要思想是把多重表结构引入到图的邻接表中，就有点像把边作为研究的基本单位，用一个多重表节点来表示一条边。\r\n\r\n\r\n### *十字链表表示 \r\n此为百度词条：十字链表（Orthogonal List)是有向图的另一种[链式存储结构](https:\u002F\u002Fbaike.baidu.com\u002Fitem\u002F%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)。该结构可以看成是将有向图的[邻接表](https:\u002F\u002Fbaike.baidu.com\u002Fitem\u002F%E9%82%BB%E6%8E%A5%E8%A1%A8)(和逆邻接表结合起来得到的。用十字链表来存储有向图，可以达到高效的存取效果。同时，代码的可读性也会得到提升。 \r\n\r\n## 我该选什么存储结构 \r\n\r\n首先，交通道路网络是双向的，所以我们可以将其视为无向图; 其次在一座城市的交通网络下，道路E 与路口 n的关系是 E \u003C\u003C n^2，而且道路是会出现两点之间多条路的情况（即多重图）所以我舍弃第一种方法; 后面两种表示方式其实我也是一知半解，我有种感觉，如果在交通道路的分层模型下，可能第三种方式要更具优势，但是目前还想不了那么远。所以我暂时选用第二种方式，用邻接表表示。 \r\n\r\n## 我的实现代码 \r\n`(代码年久失修，已失去完整内容，仅供参考)`\r\n### Graph_lnk.h \u002F\u002F V1.0.1 \r\n```C++\r\npragma once\r\n# include \r\nusing namespace std; \r\nint DefaultMaxVertices = 500; \u002F\u002F最大顶点数\r\n    auto memory_error = [](char * function, string aim) {    \r\n    cerr \u003C\u003C function \u003C\u003C \"申请\" \u003C\u003C aim.c_str() \u003C\u003C \"内存分配错误\" \u003C\u003C endl;\r\n    exit(1);\r\n}; \u002F\u002F内存申请错误的提示lamba表达式\r\n\r\nstruct Edge {  \r\nint dest; \u002F\u002F标记关系节点\r\ndouble weight;\u002F\u002F权值\r\nEdge * link;\u002F\u002F指向边的指针\r\nEdge(int num, double weight): dest(num), weight(weight), link(nullptr) {} \r\n};\r\n\r\nstruct Vertex {\r\nstring data; \u002F\u002F道路口的信息，暂时用string\r\nEdge * adj; \u002F\u002F指向边的指针\r\nVertex(string data = \"点\"): data(data), adj(nullptr) {} \r\n};  \r\n\r\nclass Graph_lnk {  \r\nfriend ostream & operator \u003C\u003C (ostream & in, Graph_lnk & G); \u002F\u002F运算符重载，图的输出\r\n\r\npublic: \r\nGraph_lnk(int sv = DefaultMaxVertices);\r\n~Graph_lnk();  \r\nint NumberOfVertices() {  return numVertices; } \u002F\u002F返回当前顶点数\r\nint NumberOfEdges() {  return numEdges; } \u002F\u002F返回当前边数\r\nVertex getVertex(return NodeTable[v]; } \u002F\u002F返回该节点  \r\n\t\t\t\t\t\t\t\t\r\nstring getValue(int v) {return NodeTable - \u003E data;} \u002F\u002F返回道路信息  \r\n\t\t\t\t\t\t\t\t\r\nbool insertEdge(int v1, int v2, double weight); \u002F\u002F插入一条边  \r\n\t\t\t\t\t\t\t\t\r\nbool insertVertex(string data); \u002F\u002F插入一个路口  \r\n\t\t\t\t\t\t\t\t\r\nprotected: int numVertices; \u002F\u002F当前顶点数  \r\n\t\t\t\t\t\t\t\t\r\nint numEdges; \u002F\u002F当前边数  \r\n\t\t\t\t\t\t\t\t\r\nprivate: Vertex * NodeTable;  \r\n\t\t\t\t\t\t\t\t\r\n};  \r\n\t\t\t\t\t\t\t\r\nGraph_lnk::Graph_lnk(int sv) {  \r\n\t\t\t\t\t\t\t\t\r\n\tnumVertices = sv;  \r\n\t\t\t\t\t\t\r\n\tnumEdges = 0;  \r\n\t\t\t\t\t\t\r\n\tNodeTable = new Vertex[DefaultMaxVertices];  \r\n\t\t\t\t\t\t\t\t\r\n\tif (NodeTable == nullptr) {  \r\n\t\t\t\t\t\t\t\t\r\n\t\tmemory_error(__func__, \"NodeTable\");  \r\n\t\t\t\t\t\t\t\t\r\n\t}  \r\n\t\t\t\t\t\t\r\n\tfor (int i = 0; i };  \r\n\t\t\t\t\t\t\r\nbool Graph_lnk::insertEdge(int v1, int v2, double weight) {  \r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\nif (v1 \u003E= 0 && v1 = 0 && v2 \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t        Edge * q = nullptr, * p = nullptr;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t        if (NodeTable[v1].adj != nullptr) {  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t            p = NodeTable[v1].adj;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t            q = p - \u003E link;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t            while (q != nullptr) {  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t                p = q;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t                q = p - \u003E link;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t            }  \r\n\t\t\t\t\t\t\r\n\t\t\t\t            q = new Edge(v2, weight);  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t            p - \u003E link = q;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t        } else {  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t            NodeTable[v1].adj = new Edge(v2, weight);  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t        }  \r\n\t\t\t\t\t\t\r\n\t\t\t\t        if (NodeTable[v2].adj != nullptr) {  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t            p = NodeTable[v2].adj;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t            q = p - \u003E link;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t            while (q != nullptr) {  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t                p = q;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t                q = p - \u003E link;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t            }  \r\n\t\t\t\t\t\t\r\n\t\t\t\t            q = new Edge(v1, weight);  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t            p - \u003E link = q;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t        } else {  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t            NodeTable[v2].adj = new Edge(v1, weight);  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t        }  \r\n\t\t\t\t\t\t\r\n\t\t\t\t        numEdges++;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t    }  \r\n\t\t\t\t\t\t\r\n\t\t\t\t    return 0;  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t}  \r\n\t\t\t\t\t\t\r\n\t\t\t\tbool Graph_lnk::insertVertex(string data) {  \r\n\t\t\t\t\t\t\r\n\t\t\t\t    if (numVertices == DefaultMaxVertices) return false;  \r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t    else {  \r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t        NodeTable[numVertices].data = data;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t        NodeTable[numVertices].adj = nullptr;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t        numVertices++;  \r\n\t\t\t\t\t\t\r\n\t\t\t\t    }  \r\n\t\t\t\t\t\t\r\n\t\t\t\t    return true;  \r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t}  \r\n\t\t\t\t\t\t\r\n\t\t\t\t    \r\n Graph_lnk::~Graph_lnk() {  \r\n\t\t\t\t\t\t\r\n\tdelete[] NodeTable;  \r\n\t\t\t\t\t\t\t\t\r\n};\r\n```\r\n\t\t\t\t\t\t\r\n## 分析与理由 \r\n在交通道路网络图的构建中，一定需要的两个函数insertEdge();和insertVertex(); 我使用两个主要的数据结构，Edge（表示边），Vertex（表示点）。用它们的集合来表示整个图，这样做可以有效的利用空间？（但是还是申请了VerTex（500）） \r\n \r\n## 缺陷与不足 \r\n不管你构建含多少个点的图，都需要申请固定的空间，只有当点小于而且越接近于500时空间利用率才最高。 \r\n插入边时，需要在两个点做增加，但是好像对于实际情况这样做并没有好处？ \r\n。。。。 \r\n \r\n## 问题与思考 \r\n作为交通网络图，是否还需要拓展一些别的功能？ \r\n在储存的过程中，是否用bit矩阵来存储数据？ \r\n能不能在插入的过程中只新增一个点上的边？ \r\n或者直接以边为基本研究单位，来构建图类？ \r\n## 心得与感悟 \r\n本来以为写一个图类，会是一件比较容易的事，没想到却也花了这么久，是考虑的太多？还是基础不牢？ \r\n刚开始想用模板类来表示，这样在后期数据类型拓展时比较方便，没想到却是发现一堆错误，还解决不了，最后要重新来过。 \r\n基础还是要牢固才可以，现在写的东西自己都感觉境界不够，没有别人那种精妙绝伦的感觉。 \r\n平常有时间多沉下心来学习，切记好高骛远，绕了一圈最后发现自己什么都不行...",order:a,authorId:1,type:"post",status:"publish",commentsNum:a,allowComment:b,allowPing:b,allowFeed:b,parent:a,views:347,likes:a}}],fetch:{},mutations:void 0}}(0,"1")));