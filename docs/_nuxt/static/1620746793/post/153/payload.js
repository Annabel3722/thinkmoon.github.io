__NUXT_JSONP__("/post/153", (function(a,b,c){return {data:[{article:{cid:153,title:"毕业设计番外篇(一)之车辆路径的计算",slug:"153",created:1549950000,modified:1553153884,text:"\u003C!--markdown--\u003E\u003E 目前，我采用的是迪杰斯特拉算法计算所有点的最短路径（感觉弗洛伊德算法会更好些？）。迪杰斯特拉算法算的是单源（V_begin)到所有点的最短距离，也就是说需要遍历一次所有的点。\r\n## 遍历V_begin\r\n```C++\r\nfor (int V_begin = 0; V_begin \u003C G-\u003Em_CrossRoad_v.size(); V_begin++) {\r\n}\r\n```\r\n\u003E 下面是迪杰斯特拉算法的流程\r\n## 1. 声明dist数组\r\n```C++\r\nvector\u003Cdouble\u003E Determined_dist(G-\u003Em_CrossRoad_v.size(), 0.0);\r\n```\r\n## 2. 初始化顶点集\r\n\r\n```C++\r\nvoid calcShortestPath(Graph *G) {\r\n    int currentPointSite,nextPointSite;\r\n    ofstream PointPathFile(DIR_RES\"PointPath.txt\"),RoadPathFile(DIR_RES\"RoadPath.txt\");\r\n    \u002F\u002F对点进行的一级遍历\r\n    for (int V_begin = 0; V_begin \u003C G-\u003Em_CrossRoad_v.size(); V_begin++) {\r\n        \u002F\u002F =================== 迪杰斯特拉算法开始 ===============================\r\n        vector\u003Cbool\u003E S(G-\u003Em_CrossRoad_v.size(), false); \u002F\u002F判断是否选中\r\n        vector\u003Cdouble\u003E dist(G-\u003Em_CrossRoad_v.size(), DBL_MAX\u002F2);\u002F\u002F dist\r\n        vector\u003Cdouble\u003E compare_dist(G-\u003Em_CrossRoad_v.size(), DBL_MAX\u002F2);\u002F\u002F 辅助dist用来取最短距离点\r\n        vector\u003Cint\u003E path(G-\u003Em_CrossRoad_v.size(),-2); \u002F\u002F path\r\n        S[V_begin] = true;\r\n        path[V_begin] = -1;\r\n        for(auto crossroad : G-\u003Em_CrossRoad_v[V_begin].JunctionRoad){\r\n            nextPointSite = G-\u003Em_Road_v[crossroad.outRoadID].m_CrossRoadToSite;\r\n            dist[nextPointSite] = G-\u003Em_Road_v[crossroad.outRoadID].m_dLength;\r\n            compare_dist[nextPointSite] = dist[nextPointSite];\r\n        }\r\n        auto min = min_element(compare_dist.begin(), compare_dist.end());\r\n        int min_element_index = distance(compare_dist.begin(), min);\r\n        compare_dist[min_element_index] = DBL_MAX\u002F2;\r\n        \u002F\u002F 循环size-1次\r\n        for(int i = 0; i \u003C G-\u003Em_CrossRoad_v.size()-1; i++){\r\n            for(auto crossroad : G-\u003Em_CrossRoad_v[min_element_index].JunctionRoad){\r\n                currentPointSite = min_element_index;\r\n                nextPointSite = G-\u003Em_Road_v[crossroad.outRoadID].m_CrossRoadToSite;\r\n                if(S[nextPointSite]){\r\n                    continue;\r\n                }\r\n                if(dist[nextPointSite] \u003E dist[currentPointSite] + G-\u003Em_Road_v[crossroad.outRoadID].m_dLength) {\r\n                    dist[nextPointSite] = dist[currentPointSite] + G-\u003Em_Road_v[crossroad.outRoadID].m_dLength;\r\n                    compare_dist[nextPointSite] = dist[nextPointSite];\r\n                    path[nextPointSite] = currentPointSite;\r\n                }\r\n            }\r\n            min = min_element(compare_dist.begin(), compare_dist.end());\r\n            min_element_index = distance(compare_dist.begin(), min);\r\n            S[min_element_index] = true;\r\n            compare_dist[min_element_index] = DBL_MAX\u002F2;\r\n        }\r\n        for(int i = 0;i\u003Cpath.size();i++){\r\n            int j = i;\r\n            bool flag = false;\r\n            while( path[j] \u003E= 0) {\r\n                flag = true;\r\n                PointPathFile \u003C\u003C path[j] \u003C\u003C \" \";\r\n                for(auto node:G-\u003Em_CrossRoad_v[j].JunctionRoad){\r\n                    if(G-\u003Em_Road_v[node.outRoadID].m_CrossRoadToSite == path[j]){\r\n                        RoadPathFile \u003C\u003C node.outRoadID \u003C\u003C \" \";\r\n                    }\r\n                }\r\n                j = path[j];\r\n            }\r\n            if(flag){RoadPathFile \u003C\u003C endl;PointPathFile \u003C\u003C endl ;}\r\n        }\r\n    }\r\n}\r\n```\r\n",order:c,authorId:a,type:"post",status:"publish",commentsNum:a,allowComment:b,allowPing:b,allowFeed:b,parent:c,views:1247,likes:a}}],fetch:{},mutations:void 0}}(1,"1",0)));