__NUXT_JSONP__("/post/219", (function(a,b,c){return {data:[{article:{cid:219,title:"在微信小程序里使用async\u002Fawait异步API及浅谈各种异步",slug:"219",created:1551844440,modified:1551858397,text:"\u003C!--markdown--\u003E\u003E 想达到本文效果，需使用wepy框架。不了解wepy？转[https:\u002F\u002Ftencent.github.io\u002Fwepy\u002Findex.html](https:\u002F\u002Ftencent.github.io\u002Fwepy\u002Findex.html)\r\n## 什么是async\u002Fawait?\r\n\u003E 在最新的ES7（ES2017）中提出的前端异步特性：async、await。\r\nasync顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成。也就是我们平常所说的异步等待。不过需注意`await只能在async函数中使用`。\r\n\r\n## 为什么需要async\u002Fawait?\r\n在async\u002Fawait之前，我们有三种方式写异步代码\r\n### 1. 嵌套回调\r\n其中思想就是,a函数执行完了得到的结果后在执行b。\r\n形如\r\n```javascript\r\nwx.getSetting({\r\n      success(res) {\r\n        console.log(res.authSetting['scope.userLocation']);\r\n        if (!res.authSetting['scope.userLocation']) {\r\n          wx.authorize({\r\n            scope: 'scope.userLocation',\r\n            fail(res) {\r\n              Toast('无法获取位置,采用默认排序');\r\n            }\r\n          });\r\n        } else {\r\n          wx.getLocation({\r\n            type: 'wgs84',\r\n            success(res) {\r\n              _this.setData({ location: res });\r\n              console.log('您的位置信息:', res);\r\n            },\r\n            fail() {\r\n              Toast('无法获取位置,采用默认排序');\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n```\r\n\u003E 上面的代码你不用看，就会感觉。这啥东西？乱七八糟的。这就是嵌套回调。很不巧，原生微信小程序开发就是这样的。\r\n\r\n### 2. 以Promise为主的链式回调\r\n\u003E 所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。形如\r\n```javascript\r\nvar p1 = new Promise((resolve, reject) =\u003E {\r\n setTimeout(resolve, 1000, 'done');\r\n })\r\np1.then(data=\u003E{\r\n console.log(data); \u002F\u002F done\r\n})\r\n```\r\n如果你的函数够多的话，那么就会一直then()下去。\r\n\u003E为了优雅，Promise提供了一个方法`Promise.all([p1,p2,p3])` ，用于将多个Promise实例，包装成一个新的Promise实例。接收的参数是一个数组,p1、p2、p3都是Promise对象\r\n分两种情况：\r\n1. p1、p2、p3的状态都是resolve的时候，Promise.all的状态才会变成resolve；\r\n2. 只要p1、p2、p3中有一个的状态为reject，那么Promise.all的状态就会变成reject；\r\n所以我们可以用Promise.all()来解决多个异步依赖调用。\r\n\r\n### 3. 使用Generators\r\n```javascript\r\nfunction *main() {\r\n    var x = yield 1;\r\n    var y = yield x;\r\n    var z = yield (y * 2);\r\n}\r\n```\r\n\u003E 上面代码中的每一条语句都会按顺序一个一个地执行。Yield关键字标明了代码中被阻塞的点（只能被generator函数自己阻塞，外部代码不能阻塞generator函数的执行），但是不会改变*main()函数中代码的执行顺序。这段代码很简单！\r\n\r\n但是，这三种写起来都还是不够优雅，ES7做了优化改进，async\u002Fawait应运而生，async\u002Fawait相比较Promise 对象then 函数的嵌套，与 Generator 执行的繁琐(需要借助co才能自动执行，否则得手动调用next())， Async\u002FAwait 可以让你轻松写出同步风格的代码同时又拥有异步机制，更加简洁，逻辑更加清晰。\r\n\r\n\u003E 示例\r\n```javascript\r\nasync a(){};\r\nconst b = await a();\r\n```\r\n\r\n## 这样做的好处？\r\n\u003E 唔，你不觉得一个优雅的代码就该是这样吗？好吧，其实这样更容易符合我们平常的思维逻辑\r\n\r\n## 回到本文的题目\r\n\u003E 在wepy1.4.1以后的版本（之前的版本都是默认开启的），默认不支持async\u002Fawait，需要用户手动加入，方法如下：\r\n### 进入项目根目录，安装runtime包\r\n```\r\nnpm install wepy-async-function --save\r\n```\r\n### 修改wepy.config.js加入runtime配置\r\n```\r\n        babel: {\r\n            \"presets\": [\r\n                \"env\"\r\n            ],\r\n            \"plugins\": [\r\n                \"transform-export-extensions\",\r\n                \"syntax-export-extensions\"\r\n            ]\r\n        }\r\n```\r\n### 在app.wpy中引入引入runtime包\r\n```\r\nimport 'wepy-async-function'; \r\n```\r\n### 在app.wpy中使API promise化\r\n\u003E 重写构造函数，使其支持async\u002Fawait。\r\n```\r\nexport default class extends wepy.app {\r\n    constructor () {\r\n        super();\r\n        this.use('promisify');\r\n    }\r\n}\r\n```\r\n### 重启编译\r\n```\r\nwepy build --no-cache\r\n```\r\n\r\n## 使用示例\r\n\u003E 在wepy框架官方文档中已说明，对所有的微信小程序都支持async\u002Fawait操作。只需将形如`wx.getuserInfo`改写为`wepy.getuserInfo`即可\r\n```\r\nasync userInfoAsync() {\r\n    const _this = this;\r\n    const data = await wepy.getSetting(); \u002F\u002F获取设置数据\r\n    if (data.authSetting['scope.userInfo']) { \u002F\u002F判断是否有获取用户信息的权限\r\n      await wepy.login(); \u002F\u002F登录\r\n      let data = await wepy.getUserInfo();\u002F\u002F获取用户信息\r\n      _this.userInfo = data.userInfo;\u002F\u002F采用wepy框架修改过后的功能，支持直接赋值数据绑定\r\n      _this.$apply(); \u002F\u002F在async的函数中，必须主动执行`$apply()`来进行脏数据检查\r\n    }\r\n  }\r\nasync onShow() {\r\n    this.userInfoAsync(); \u002F\u002F调用async函数\r\n  }\r\n```\r\n\u003E 以上代码实现了异步同步用户userInfo的功能\r\n\r\n参考文献:\r\n1. [使用Promise链式调用解决多个异步回调的问题](https:\u002F\u002Fwww.jb51.net\u002Farticle\u002F103068.htm)\r\n2. [关于js的callback回调函数以及嵌套回调函数的执行过程理解](https:\u002F\u002Fblog.csdn.net\u002Fsamt007\u002Farticle\u002Fdetails\u002F54647361)\r\n3. [ES6 Generators并发](https:\u002F\u002Fwww.cnblogs.com\u002Fjaxu\u002Fp\u002F6592210.html)\r\n4. [ES7前端异步玩法：async\u002Fawait理解](https:\u002F\u002Fwww.cnblogs.com\u002FleungUwah\u002Fp\u002F7932912.html)\r\n5. [理解 JavaScript 的 async\u002Fawait](https:\u002F\u002Fsegmentfault.com\u002Fa\u002F1190000007535316?utm_source=tag-newest)\r\n6. [Async\u002Fawait学习](https:\u002F\u002Fsegmentfault.com\u002Fa\u002F1190000013292562?utm_source=channel-newest)\r\n7. [浅谈async\u002Fawait](https:\u002F\u002Fwww.jianshu.com\u002Fp\u002F1e75bd387aa0)\r\n8. [wepy项目中使用async await](https:\u002F\u002Fgithub.com\u002FTencent\u002Fwepy\u002Fwiki\u002Fwepy%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8async-await)",order:a,authorId:c,type:"post",status:"publish",commentsNum:a,allowComment:b,allowPing:b,allowFeed:b,parent:a,views:2893,likes:c}}],fetch:{},mutations:void 0}}(0,"1",1)));