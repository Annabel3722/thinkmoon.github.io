__NUXT_JSONP__("/post/96", (function(a,b){return {data:[{article:{cid:96,title:"pyenv——简单的python版本管理器",slug:"96",created:1547981040,modified:1567477635,text:"\u003C!--markdown--\u003E## 简单的python版本管理器: pyenv\r\n\r\n\u003E pyenv可以让你轻松的在各版本的python环境中切换自如，它是一个简单而又不引人注目并遵循UNIX传统的专用工具。\r\n\r\n这个项目是从[rbenv](https:\u002F\u002Fgithub.com\u002Frbenv\u002Frbenv)和[ruby-build](https:\u002F\u002Fgithub.com\u002Frbenv\u002Fruby-build)fork而来, 并且在配合Python的情况下做了适当的修改.\r\n\r\n![Terminal output example][1]\r\n\r\n\r\n## pyenv能做什么？\r\n\r\n* 让你在**用户基础**上改变全局Python版本.\r\n* 支持为**每一个项目**设立一个Python版本.\r\n* 允许您使用**环境变量**覆盖Python版本.\r\n* 在**多个python环境**中搜索命令,这有助于在Python版本中进行测试 [tox](https:\u002F\u002Fpypi.python.org\u002Fpypi\u002Ftox).\r\n\r\n\r\n## 与pythonbrew和pythonz相比，pyenv不能做什么?\r\n\r\n* **不依赖于Python本身。** pyenv是由纯shell脚本制作的。没有Python的引导问题。\r\n* **不需要加载到你的shell中。**相反，pyenv的shim方法的工作原理是在`$ PATH`中添加一个目录。\r\n* **不能管理virtualenv** 当然你可以自行创建virtualenv [virtualenv](https:\u002F\u002Fpypi.python.org\u002Fpypi\u002Fvirtualenv)或者使用[pyenv-virtualenv](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv-virtualenv)去自动化构建\r\n\r\n## 工作原理\r\n\r\n在较高的层次上，pyenv使用shim拦截Python命令注入`PATH`的可执行文件, 确定哪个Python版本已由您的应用程序指定，并传递您的命令使用你想要的Python安装版本。\r\n\r\n### 理解PATH(环境变量路径)\r\n\r\n当你执行命令,如`python`或者`pip`, 你的操作系统会搜索目录列表以查找可执行文件的那个名字.此目录列表位于环境变量中称为`PATH`, 列表中的每个目录使用用冒号分隔.\r\n\r\n![PATH.png][2]\r\n\r\n`PATH`中的目录从左到右搜索，因此首先匹配在列表开头的目录中的可执行文件, 然后一次往右匹配。在这个例子中，首先搜索`\u002Fusr\u002Flocal\u002Fsbin`目录，然后搜索`\u002Fusr\u002Flocal\u002Fbin`，然后是`\u002Fusr\u002Fsbin`。\r\n\r\n### 理解Shims(垫片)\r\n\r\npyenv的工作原理是在你的`PATH`前面插入一个shims目录，这样一来系统在搜索Python的时候第一个找到的就是pyenv管理的Python环境。这个插到最前面的路径就叫做垫片（shims）\r\n\r\n    $(pyenv root)\u002Fshims:\u002Fusr\u002Flocal\u002Fbin:\u002Fusr\u002Fbin:\u002Fbin\r\n\r\n通过一个叫做为_rehashing_的进程, pyenv维护shims目录以匹配每个已安装版本的每个Python命令,比如`python`，`pip`等。\r\n\r\n垫片是轻量级可执行文件，只是简单地传递命令到pyenv。所以只要安装了pyenv，当你运行时，比如说，`pip`，你的操作系统将执行以下操作：\r\n\r\n* 在`PATH`中搜索名为`pip`的可执行文件\r\n* 在`PATH`的开头找到名为`pip`的pyenv垫片\r\n* 运行名为`pip`的垫片，然后将命令传递给属于pyenv的pip命令\r\n\r\n### 选择Python版本\r\n\r\n执行shims程序时，pyenv会确定要使用的Python版本,并按此以下资源顺序读取:\r\n\r\n1. `PYENV_VERSION`环境变量（如果指定）. 你可以使用[`pyenv shell`](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fblob\u002Fmaster\u002FCOMMANDS.md#pyenv-shell) 去设置环境变量在你当前shell session.\r\n\r\n2. 当前特定于应用程序的`.python-version`文件目录（如果有）. 您可以使用 [`pyenv local`](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fblob\u002Fmaster\u002FCOMMANDS.md#pyenv-local)修改当前目录`.python-version`文件.\r\n\r\n3. 通过搜索每个上层目录,找到第一个`.python-version`文件（如果有的话），直到到达文件系统的根目录\r\n\r\n4. 全局`$(pyenv root)\u002Fversion`文件. 您可以使用[`pyenv global`](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fblob\u002Fmaster\u002FCOMMANDS.md#pyenv-global) 修改这个文件. 如果是该全局文件不存在，pyenv假设您要使用“系统”Python。(换句话说，如果pyenv不在您的PATH中，那么任何版本都会运行.)\r\n\r\n**NOTE:** 您可以同时激活多个版本，甚至包括Python2或Python3的任何版本. 这允许平行使用Python2和Python3，并且需要像`tox`这样的工具. 例如，要设置你的首次使用的系统Python和Python3的路径（在这个例子中设置为2.7.9和3.4.2），但也可以在你的`PATH`使用Python 3.3.6,3.2和2.5，首先是`pyenv install`缺少的版本，然后设置`pyenv`全局3.3.6 3.2 2.5`.这时, 使用`pyenv which`应该能够找到每个可执行路径, 例如`pyenv which python2.5`（应该显示`$（pyenv root\u002Fversions\u002F2.5 \u002Fbin\u002Fpython2.5`) 或者`pyenv which python3.4`(应该显示系统Python3路径). 您还可以指定多个`.python-version`文件中的版本，由换行符或任何空格分隔。\r\n\r\n### 定位Python的安装路径\r\n\r\n一旦pyenv确定了您的应用程序具有哪个版本的Python, 它将命令传递给相应的Python.\r\n\r\n每个Python版本都安装在自己的目录下\r\n`$(pyenv root)\u002Fversions`.\r\n\r\n例如，您可能安装了这些版本:\r\n\r\n* `$(pyenv root)\u002Fversions\u002F2.7.8\u002F`\r\n* `$(pyenv root)\u002Fversions\u002F3.4.2\u002F`\r\n* `$(pyenv root)\u002Fversions\u002Fpypy-2.4.0\u002F`\r\n\r\n就pyenv而言，版本名称只是其中的目录名\r\n\r\n`$(pyenv root)\u002Fversions`.\r\n\r\n### 管理虚拟环境\r\n\r\n有一个叫做[pyenv-virtualenv](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv-virtualenv)的pyenv插件, 它有很多功能，可帮助pyenv用户管理virtualenv或Anaconda创建的虚拟环境。因为那些虚拟环境的`activate`脚本依赖于改变shell的`$ PATH`变量, \r\n它会去hook拦截pyenv的shim样式命令钩子.如果您有计划使用这些虚拟环境，我们建议您安装pyenv-virtualenv。\r\n\r\n\r\n----\r\n\r\n\r\n## 安装\r\n\r\n如果您是macOS,推荐转至[installing with Homebrew](#homebrew-on-macos).\r\n\r\n\r\n### 自动化安装器\r\n\r\n访问以下项目:\r\nhttps:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv-installer\r\n\r\n\r\n### 基于GitHub检出\r\n\r\n\r\n这可以让你一直保持最新版本的pyenv, 并且fork上游分支的任何变化\r\n\r\n1. **在哪里检出.**\r\n   我们建议`$HOME\u002F.pyenv` (但其实您可以安装在任何地方).\r\n\r\n        $ git clone https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv.git ~\u002F.pyenv\r\n\r\n\r\n2. **Define environment variable `PYENV_ROOT`** to point to the path where\r\n   pyenv repo is cloned and add `$PYENV_ROOT\u002Fbin` to your `$PATH` for access\r\n   to the `pyenv` command-line utility.\r\n\r\n    ```sh\r\n    $ echo 'export PYENV_ROOT=\"$HOME\u002F.pyenv\"' \u003E\u003E ~\u002F.bash_profile\r\n    $ echo 'export PATH=\"$PYENV_ROOT\u002Fbin:$PATH\"' \u003E\u003E ~\u002F.bash_profile\r\n    ```\r\n    **Zsh note**: Modify your `~\u002F.zshenv` file instead of `~\u002F.bash_profile`.\r\n    **Ubuntu and Fedora note**: Modify your `~\u002F.bashrc` file instead of `~\u002F.bash_profile`.\r\n    **Proxy note**: If you use a proxy, export `http_proxy` and `HTTPS_PROXY` too.\r\n\r\n3. **Add `pyenv init` to your shell** to enable shims and autocompletion.\r\n   Please make sure `eval \"$(pyenv init -)\"` is placed toward the end of the shell\r\n   configuration file since it manipulates `PATH` during the initialization.\r\n    ```sh\r\n    $ echo -e 'if command -v pyenv 1\u003E\u002Fdev\u002Fnull 2\u003E&1; then\\n  eval \"$(pyenv init -)\"\\nfi' \u003E\u003E ~\u002F.bash_profile\r\n    ```\r\n    - **Zsh note**: Modify your `~\u002F.zshenv` file instead of `~\u002F.bash_profile`.\r\n    - **fish note**: Use `pyenv init - | source` instead of `eval (pyenv init -)`.\r\n    - **Ubuntu and Fedora note**: Modify your `~\u002F.bashrc` file instead of `~\u002F.bash_profile`.\r\n\r\n    **General warning**: There are some systems where the `BASH_ENV` variable is configured\r\n    to point to `.bashrc`. On such systems you should almost certainly put the abovementioned line\r\n    `eval \"$(pyenv init -)\"` into `.bash_profile`, and **not** into `.bashrc`. Otherwise you\r\n    may observe strange behaviour, such as `pyenv` getting into an infinite loop.\r\n    See [#264](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fissues\u002F264) for details.\r\n\r\n4. **Restart your shell so the path changes take effect.**\r\n   You can now begin using pyenv.\r\n    ```sh\r\n    $ exec \"$SHELL\"\r\n    ```\r\n\r\n5. **Install Python build dependencies** before attempting to install a new Python version.  The\r\n   [pyenv wiki](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fwiki) provides suggested installation packages\r\n   and commands for various operating systems.\r\n\r\n6. **Install Python versions into `$(pyenv root)\u002Fversions`.**\r\n   For example, to download and install Python 2.7.8, run:\r\n    ```sh\r\n    $ pyenv install 2.7.8\r\n    ```\r\n   **NOTE:** If you need to pass configure option to build, please use\r\n   ```CONFIGURE_OPTS``` environment variable.\r\n\r\n   **NOTE:** If you want to use proxy to download, please use `http_proxy` and `https_proxy`\r\n   environment variable.\r\n\r\n   **NOTE:** If you are having trouble installing a python version,\r\n   please visit the wiki page about\r\n   [Common Build Problems](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fwiki\u002FCommon-build-problems)\r\n\r\n\r\n#### Upgrading\r\n\r\nIf you've installed pyenv using the instructions above, you can\r\nupgrade your installation at any time using git.\r\n\r\nTo upgrade to the latest development version of pyenv, use `git pull`:\r\n\r\n```sh\r\n$ cd $(pyenv root)\r\n$ git pull\r\n```\r\n\r\nTo upgrade to a specific release of pyenv, check out the corresponding tag:\r\n\r\n```sh\r\n$ cd $(pyenv root)\r\n$ git fetch\r\n$ git tag\r\nv0.1.0\r\n$ git checkout v0.1.0\r\n```\r\n\r\n### Uninstalling pyenv\r\n\r\nThe simplicity of pyenv makes it easy to temporarily disable it, or\r\nuninstall from the system.\r\n\r\n1. To **disable** pyenv managing your Python versions, simply remove the\r\n  `pyenv init` line from your shell startup configuration. This will\r\n  remove pyenv shims directory from PATH, and future invocations like\r\n  `python` will execute the system Python version, as before pyenv.\r\n\r\n  `pyenv` will still be accessible on the command line, but your Python\r\n  apps won't be affected by version switching.\r\n\r\n2. To completely **uninstall** pyenv, perform step (1) and then remove\r\n   its root directory. This will **delete all Python versions** that were\r\n   installed under `` $(pyenv root)\u002Fversions\u002F `` directory:\r\n    ```sh\r\n    rm -rf $(pyenv root)\r\n    ```\r\n   If you've installed pyenv using a package manager, as a final step\r\n   perform the pyenv package removal. For instance, for Homebrew:\r\n\r\n        brew uninstall pyenv\r\n\r\n### Homebrew on macOS\r\n\r\nYou can also install pyenv using the [Homebrew](https:\u002F\u002Fbrew.sh)\r\npackage manager for macOS.\r\n\r\n    $ brew update\r\n    $ brew install pyenv\r\n\r\n\r\nTo upgrade pyenv in the future, use `upgrade` instead of `install`.\r\n\r\nThen follow the rest of the post-installation steps under [Basic GitHub Checkout](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv#basic-github-checkout) above, starting with #3 (\"Add `pyenv init` to your shell to enable shims and autocompletion\").\r\n\r\n### Advanced Configuration\r\n\r\nSkip this section unless you must know what every line in your shell\r\nprofile is doing.\r\n\r\n`pyenv init` is the only command that crosses the line of loading\r\nextra commands into your shell. Coming from rvm, some of you might be\r\nopposed to this idea. Here's what `pyenv init` actually does:\r\n\r\n1. **Sets up your shims path.** This is the only requirement for pyenv to\r\n   function properly. You can do this by hand by prepending\r\n   `$(pyenv root)\u002Fshims` to your `$PATH`.\r\n\r\n2. **Installs autocompletion.** This is entirely optional but pretty\r\n   useful. Sourcing `$(pyenv root)\u002Fcompletions\u002Fpyenv.bash` will set that\r\n   up. There is also a `$(pyenv root)\u002Fcompletions\u002Fpyenv.zsh` for Zsh\r\n   users.\r\n\r\n3. **Rehashes shims.** From time to time you'll need to rebuild your\r\n   shim files. Doing this on init makes sure everything is up to\r\n   date. You can always run `pyenv rehash` manually.\r\n\r\n4. **Installs the sh dispatcher.** This bit is also optional, but allows\r\n   pyenv and plugins to change variables in your current shell, making\r\n   commands like `pyenv shell` possible. The sh dispatcher doesn't do\r\n   anything crazy like override `cd` or hack your shell prompt, but if\r\n   for some reason you need `pyenv` to be a real script rather than a\r\n   shell function, you can safely skip it.\r\n\r\nTo see exactly what happens under the hood for yourself, run `pyenv init -`.\r\n\r\n\r\n### Uninstalling Python Versions\r\n\r\nAs time goes on, you will accumulate Python versions in your\r\n`$(pyenv root)\u002Fversions` directory.\r\n\r\nTo remove old Python versions, `pyenv uninstall` command to automate\r\nthe removal process.\r\n\r\nAlternatively, simply `rm -rf` the directory of the version you want\r\nto remove. You can find the directory of a particular Python version\r\nwith the `pyenv prefix` command, e.g. `pyenv prefix 2.6.8`.\r\n\r\n\r\n----\r\n\r\n\r\n## Command Reference\r\n\r\nSee [COMMANDS.md](COMMANDS.md).\r\n\r\n\r\n----\r\n\r\n## Environment variables\r\n\r\nYou can affect how pyenv operates with the following settings:\r\n\r\nname | default | description\r\n-----|---------|------------\r\n`PYENV_VERSION` | | Specifies the Python version to be used.\u003Cbr\u003EAlso see [`pyenv shell`](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fblob\u002Fmaster\u002FCOMMANDS.md#pyenv-shell)\r\n`PYENV_ROOT` | `~\u002F.pyenv` | Defines the directory under which Python versions and shims reside.\u003Cbr\u003EAlso see `pyenv root`\r\n`PYENV_DEBUG` | | Outputs debug information.\u003Cbr\u003EAlso as: `pyenv --debug \u003Csubcommand\u003E`\r\n`PYENV_HOOK_PATH` | [_see wiki_][hooks] | Colon-separated list of paths searched for pyenv hooks.\r\n`PYENV_DIR` | `$PWD` | Directory to start searching for `.python-version` files.\r\n`PYTHON_BUILD_ARIA2_OPTS` | | Used to pass additional parameters to [`aria2`](https:\u002F\u002Faria2.github.io\u002F).\u003Cbr\u003Eif `aria2c` binary is available on PATH, pyenv use `aria2c` instead of `curl` or `wget` to download the Python Source code. If you have an unstable internet connection, you can use this variable to instruct `aria2` to accelerate the download.\u003Cbr\u003EIn most cases, you will only need to use `-x 10 -k 1M` as value to `PYTHON_BUILD_ARIA2_OPTS` environment variable\r\n\r\n\r\n\r\n## Development\r\n\r\nThe pyenv source code is [hosted on\r\nGitHub](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv).  It's clean, modular,\r\nand easy to understand, even if you're not a shell hacker.\r\n\r\nTests are executed using [Bats](https:\u002F\u002Fgithub.com\u002Fsstephenson\u002Fbats):\r\n\r\n    $ bats test\r\n    $ bats\u002Ftest\u002F\u003Cfile\u003E.bats\r\n\r\nPlease feel free to submit pull requests and file bugs on the [issue\r\ntracker](https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fissues).\r\n\r\n\r\n  [pyenv-virtualenv]: https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv-virtualenv#readme\r\n  [hooks]: https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fwiki\u002FAuthoring-plugins#pyenv-hooks\r\n\r\n### Version History\r\n\r\nSee [CHANGELOG.md](CHANGELOG.md).\r\n\r\n### License\r\n\r\n[The MIT License](LICENSE)\r\n\r\n\r\n  [1]: https:\u002F\u002Fblog.cdn.thinkmoon.cn\u002Fblog\u002Ftypecho\u002F2019-09-03T02:26:51.png\r\n  [2]: https:\u002F\u002Fwww.thinkmoon.cn\u002Fusr\u002Fuploads\u002F2019\u002F01\u002F1698659685.png",order:a,authorId:1,type:"post",status:"publish",commentsNum:a,allowComment:b,allowPing:b,allowFeed:b,parent:a,views:901,likes:3}}],fetch:{},mutations:void 0}}(0,"1")));