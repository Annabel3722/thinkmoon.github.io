__NUXT_JSONP__("/post/77", (function(a,b){return {data:[{article:{cid:77,title:"C++11新特性之auto的妙用",slug:"77",created:1493253000,modified:1547608361,text:"\u003C!--markdown--\u003E\u003E C++11引入了auto和decltype关键字实现类型推导，通过这两个关键字不仅能方便地获得复杂的类型，还能简化书写，提高编码效率。下面说一下C++中的auto\r\n\r\n### 旧标准\r\nauto其实并不是一个新的关键字，在旧的标准C++98\u002F03中，它代表着“具有自动存储周期的局部变量”。啥意思呢？就是我们平常所说的变量，他与static相对。就是说所有非static类型的都是“具有自动存储期的”。也就是说在旧的标准下。\r\n```C++\r\nautoint i =3;\u002F\u002F等价于int i=3;\r\n```\r\n### 新标准\r\n在C++11中，auto作为一个新的类型指示符（如int，double）来指示编译器的，但是auto申明的变量的类型必须由编译器在编译时期推导出来，也称类型推导。这种类型推导不是C++所独有的，还有很多具备这种能力的语言（如Python，Javascript）。我们先来看一段Python代码\r\n```python\r\nname =\"thinkmoon\"print\"hello,\"+ name \r\n```\r\n在这里的name是不需要定义类型的，因为这个类型很容易被推导为字符串性，如过要想在C++中实现这种效果，我们可以这样。\r\n```C++\r\n#include\u003Ciostream\u003E\r\nint main(){\r\n\tauto name =\"thinkmoon\"; \r\n\tstd::cout \u003C\u003C\"hello,\"\u003C\u003C name \u003C\u003C std::endl;\r\n\treturn0;\r\n}\r\n```\r\n效果是一样的，是不是觉得写起来特别的方便呢？\r\n\r\n但是需要注意的是，在C++中这种静态类型推导是发生在编译期间的。而像Python这种动态类型推导却是发生在运行期间的。\r\n### auto的基本用法\r\n```C++\r\n#include\u003Ciostream\u003E\r\nusingnamespace std;\r\nint main(){\r\nauto x =5; \r\ncout \u003C\u003C x \u003C\u003C endl;\u002F\u002Fx被推导为intauto p =newauto(1);    \r\ncout \u003C\u003C\"*\"\u003C\u003C p \u003C\u003C\"=\"\u003C\u003C*p \u003C\u003C endl;\u002F\u002Fp被推导为\r\nint *constauto*v =&x, u =6; \r\ncout \u003C\u003C\"*\"\u003C\u003C v \u003C\u003C\"=\"\u003C\u003C*v \u003C\u003C\"\\n u=\"\u003C\u003C u \u003C\u003C endl;\u002F\u002Fv被推导为const int *，u被推导const int\r\n}\r\n```\r\n对于最后一个类型推导有几个需要注意\r\n\r\n1.  v被推导为const int *而这里auto代替int，但是u等于6还是要写的，否则编译器会报错。\r\n2.  u的等号后面只能写整型的变量，否则会报错，因为不能让编译器产生具有二义性的推断。\r\n\u003E 其实我们学习的时候可以把auto理解为占位符，它只是占着一个位置并不做其它的事情，由编译器将其类型推导出来再用对应的类型去运行，所以这个时候auto的类型推导是不能让编译器产生二义性的。  \r\n\r\n### auto的推导规则\r\n```C++\r\nint x =0;auto* a =&x;\u002F\u002Fauto推导为int，\r\nauto b =&x;\u002F\u002Fauto推导为int *，即使不申明为指针也能推断为指针\r\nauto& c = x;\u002F\u002Fauto推导为int，等价于int \r\nauto d = c;\u002F\u002Fauto推导为int，auto会抛弃右值的引用类型\r\nconst auto e = x;\u002F\u002Fe是const int类型，\r\nauto f = e;\u002F\u002Ff是int型constauto&g = x;\u002F\u002Fg是const \r\nint & auto & h = g;  \u002F\u002Fh是const int & \r\n```\r\n\r\n\u003E 总结：\r\n1.  当不申明为引用或者指针时，auto的推导规则会抛弃对应右值的cv限定符（cv-qualifier，const，volatile限定符的总称）。\r\n2.  当申明为引用或者指针时，auto推导规则会保留右值的cv属性。\r\n\r\n### auto的限制\r\n1.  auto s\r\n\u003E 错误原因:s没有明确的类型，auto无法推断。\r\n\r\n2.  void fun(auto a=1){….}\r\n\u003E 错误原因：auto类型推导不能用作函数参数。\r\n3.  auto不能用于非静态成员函数\r\n\r\n```C++\r\nstruct Foo\r\n{\r\n\tauto var_1=0;\u002F\u002F错误，auto不能用于非静态成员函数\r\n\tstatic const auto var_2=0;\u002F\u002FOK，var_2为static const int\r\n}\r\n```\r\n### 4.  auto无法定义数组\r\n```\r\nint main()\r\n{\r\n\tint arr[10]={0};\r\n\tauto aa    = arr; \u002F\u002FOK,aa为int *\r\n\tauto bb[10]=arr;\u002F\u002Ferror,auto无法定义数组\r\n}\r\n```\r\n### 5.  auto无法推导出模板参数\r\n```C++\r\nBar\u003Cint\u003E bar;\r\nBar\u003Cauto\u003E bb = bar;\u002F\u002Ferror,auto无法推导出模板参数\r\n```\r\n### auto的优势\r\n既然auto的功能特性这么方便，那么它的优势在哪？或者说，我们什么时候使用它能达到神效呢？\r\n1.  遍历vector\r\n\u003E 这是一个简单的遍历。\r\n`vector\u003Cint\u003E vs;for(auto i = vs.begin(); i \u003C vs.end(); i++){......}`\r\n其实还可以更简单\r\n`for(auto var : vs){.......}`\r\n2.  待补充。。。。。。。嘿嘿！",order:a,authorId:1,type:"post",status:"publish",commentsNum:a,allowComment:b,allowPing:b,allowFeed:b,parent:a,views:868,likes:a}}],fetch:{},mutations:void 0}}(0,"1")));