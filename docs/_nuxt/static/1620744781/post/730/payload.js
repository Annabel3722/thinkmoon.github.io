__NUXT_JSONP__("/post/730", (function(a,b){return {data:[{article:{cid:730,title:"【leetcode】5. Longest Palindromic Substring最长回文子串",slug:"730",created:1579357380,modified:1580971438,text:"\u003C!--markdown--\u003E![5. Longest Palindromic Substring最长回文子串][1]\r\n## 解法1：中心拓展算法\r\n### 思路\r\n首先，我们知道回文串一定是对称的，所以我们可以选择一个对称中心，进行左右扩展，判断左右字符是否相等即可。\r\n由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n+n-1 个中心。\r\n### 实现代码\r\n```python\r\nclass Solution:\r\n    def longestPalindrome(self, s: str) -\u003E str:\r\n        n = len(s)\r\n        Max,sub = 0,s[0:1]\r\n        for i in range(n):\r\n            tmp = self.searchPalindrome(i-1,i+1,s)\r\n            if len(tmp) \u003E Max:\r\n                Max = len(tmp)\r\n                sub = tmp\r\n            tmp = self.searchPalindrome(i-1,i,s)\r\n            if len(tmp) \u003E Max:\r\n                Max = len(tmp)\r\n                sub = tmp    \r\n        return sub\r\n    \r\n    def searchPalindrome(self, left: int, right: int, s: str) -\u003E int:\r\n        sub = \"\"\r\n        while left != -1 and right != len(s):\r\n            if s[left] == s[right]:\r\n                sub = s[left:right+1]\r\n                left-=1\r\n                right+=1\r\n            else : break\r\n        return sub\r\n```\r\n\r\n### 马拉车算法\r\n```python\r\nclass Solution:\r\n    # Manacher 算法\r\n    def longestPalindrome(self, s: str) -\u003E str:\r\n        # 特判 \r\n        if len(s) \u003C 2 or s == s[::-1]:\r\n            return s\r\n\r\n        # 得到预处理字符串\r\n        t = \"#\" + \"#\".join(s) + \"#\"\r\n\r\n        # 新字符串的长度\r\n        t_len = len(t)\r\n\r\n        # 数组 p 记录了扫描过的回文子串的信息\r\n        p = [0]*t_len\r\n\r\n        # 双指针，它们是一一对应的，须同时更新\r\n        max_right = 0\r\n        center = 0\r\n\r\n        # 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度\r\n        max_len = 1\r\n        # 原始字符串的最长回文子串的起始位置，与 max_len 必须同时更新\r\n        start = 1\r\n\r\n        for i in range(t_len):\r\n            if i \u003C max_right:\r\n                mirror = 2 * center - i\r\n                # 这一行代码是 Manacher 算法的关键所在，要结合图形来理解\r\n                p[i] = min(max_right - i, p[mirror])\r\n\r\n            # 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中\r\n            left = i - (1 + p[i])\r\n            right = i + (1 + p[i])\r\n\r\n            # left \u003E= 0 and right \u003C t_len 保证不越界\r\n            # t[left] == t[right] 表示可以扩散 1 次\r\n            while left \u003E= 0 and right \u003C t_len and t[left] == t[right]:\r\n                p[i] += 1\r\n                left -= 1\r\n                right += 1\r\n\r\n            # 根据 max_right 的定义，它是遍历过的 i 的 i + p[i] 的最大者\r\n            # 如果 max_right 的值越大，进入上面 i \u003C max_right 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了\r\n            if i + p[i] \u003E max_right:\r\n                # max_right 和 center 需要同时更新\r\n                max_right = i + p[i]\r\n                center = i\r\n\r\n            if p[i] \u003E max_len:\r\n                # 记录最长回文子串的长度和相应它在原始字符串中的起点\r\n                max_len = p[i]\r\n                start = (i - max_len) \u002F\u002F 2\r\n        return s[start: start + max_len]\r\n```\r\n### 成果\r\n![2020-01-19T15:04:32.png][2]\r\n\r\n\r\n  [1]: https:\u002F\u002Fblog.cdn.thinkmoon.cn\u002Fblog\u002Ftypecho\u002F2020-01-18T14:20:17.png\r\n  [2]: https:\u002F\u002Fblog.cdn.thinkmoon.cn\u002Fblog\u002Ftypecho\u002F2020-01-19T15:04:32.png",order:b,authorId:1,type:"post",status:"publish",commentsNum:4,allowComment:a,allowPing:a,allowFeed:a,parent:b,views:985,likes:11}}],fetch:{},mutations:void 0}}("1",0)));