__NUXT_JSONP__("/post/519", {data:[{article:"\u003C!--markdown--\u003E说到交通网路的模拟化表示，那就不得不用到数据结构中的图。想必这应该是最方便形象的表示方法了把。 \n\u003Ch2 id=\"图的概念\"\u003E图的概念\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E图是由顶点集合及顶点之间关系的集合组成的一种数据结构，Graph = （V，E）。\n其中顶点集合V = { x | x ∈ 某个数据对象集}是个有穷非空集合。E = { &lt;x, y&gt; | x , y ∈ V &amp;&amp; Path( x , y )} ，即边集。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"我所知的图的存储结构\"\u003E我所知的图的存储结构\u003C\u002Fh2\u003E\n\u003Ch3 id=\"邻接矩阵表示\"\u003E邻接矩阵表示\u003C\u002Fh3\u003E\n\u003Cp\u003E邻接矩阵的表示，首先将所有的顶点信息组成一个表。然后利用一个矩阵来表示各顶点之间的相邻关系，称之为邻接矩阵。 \u003C\u002Fp\u003E\n\u003Ch3 id=\"邻接表表示\"\u003E邻接表表示\u003C\u002Fh3\u003E\n\u003Cp\u003E在第i行的单链表中，各节点（或称边节点）分别存放与同一个顶点Vi关联的各条边。各个节点配有其标识（及对应的顶点）和权值（若为有权图）以及指向另一个边节点的指针。 \u003C\u002Fp\u003E\n\u003Ch3 id=\"邻接多重表表示\"\u003E*邻接多重表表示\u003C\u002Fh3\u003E\n\u003Cp\u003E邻接多重表的表示，主要一处理图的边为主（为什么会有这个需求？在什么情况会用到？），要求每条边处理一次的实际应用中特别有用（比如？）。它的主要思想是把多重表结构引入到图的邻接表中，就有点像把边作为研究的基本单位，用一个多重表节点来表示一条边。\u003C\u002Fp\u003E\n\u003Ch3 id=\"十字链表表示\"\u003E*十字链表表示\u003C\u002Fh3\u003E\n\u003Cp\u003E此为百度词条：十字链表（Orthogonal List)是有向图的另一种\u003Ca href=\"https:\u002F\u002Fbaike.baidu.com\u002Fitem\u002F%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84\"\u003E链式存储结构\u003C\u002Fa\u003E。该结构可以看成是将有向图的\u003Ca href=\"https:\u002F\u002Fbaike.baidu.com\u002Fitem\u002F%E9%82%BB%E6%8E%A5%E8%A1%A8\"\u003E邻接表\u003C\u002Fa\u003E(和逆邻接表结合起来得到的。用十字链表来存储有向图，可以达到高效的存取效果。同时，代码的可读性也会得到提升。 \u003C\u002Fp\u003E\n\u003Ch2 id=\"我该选什么存储结构\"\u003E我该选什么存储结构\u003C\u002Fh2\u003E\n\u003Cp\u003E首先，交通道路网络是双向的，所以我们可以将其视为无向图; 其次在一座城市的交通网络下，道路E 与路口 n的关系是 E &lt;&lt; n^2，而且道路是会出现两点之间多条路的情况（即多重图）所以我舍弃第一种方法; 后面两种表示方式其实我也是一知半解，我有种感觉，如果在交通道路的分层模型下，可能第三种方式要更具优势，但是目前还想不了那么远。所以我暂时选用第二种方式，用邻接表表示。 \u003C\u002Fp\u003E\n\u003Ch2 id=\"我的实现代码\"\u003E我的实现代码\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003E(代码年久失修，已失去完整内容，仅供参考)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"graph_lnkh--v101\"\u003EGraph_lnk.h \u002F\u002F V1.0.1\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-C++\"\u003Epragma once\n# include \nusing namespace std; \nint DefaultMaxVertices = 500; \u002F\u002F最大顶点数\n    auto memory_error = [](char * function, string aim) {    \n    cerr &lt;&lt; function &lt;&lt; &quot;申请&quot; &lt;&lt; aim.c_str() &lt;&lt; &quot;内存分配错误&quot; &lt;&lt; endl;\n    exit(1);\n}; \u002F\u002F内存申请错误的提示lamba表达式\n\nstruct Edge {  \nint dest; \u002F\u002F标记关系节点\ndouble weight;\u002F\u002F权值\nEdge * link;\u002F\u002F指向边的指针\nEdge(int num, double weight): dest(num), weight(weight), link(nullptr) {} \n};\n\nstruct Vertex {\nstring data; \u002F\u002F道路口的信息，暂时用string\nEdge * adj; \u002F\u002F指向边的指针\nVertex(string data = &quot;点&quot;): data(data), adj(nullptr) {} \n};  \n\nclass Graph_lnk {  \nfriend ostream &amp; operator &lt;&lt; (ostream &amp; in, Graph_lnk &amp; G); \u002F\u002F运算符重载，图的输出\n\npublic: \nGraph_lnk(int sv = DefaultMaxVertices);\n~Graph_lnk();  \nint NumberOfVertices() {  return numVertices; } \u002F\u002F返回当前顶点数\nint NumberOfEdges() {  return numEdges; } \u002F\u002F返回当前边数\nVertex getVertex(return NodeTable[v]; } \u002F\u002F返回该节点  \n                                \nstring getValue(int v) {return NodeTable - &gt; data;} \u002F\u002F返回道路信息  \n                                \nbool insertEdge(int v1, int v2, double weight); \u002F\u002F插入一条边  \n                                \nbool insertVertex(string data); \u002F\u002F插入一个路口  \n                                \nprotected: int numVertices; \u002F\u002F当前顶点数  \n                                \nint numEdges; \u002F\u002F当前边数  \n                                \nprivate: Vertex * NodeTable;  \n                                \n};  \n                            \nGraph_lnk::Graph_lnk(int sv) {  \n                                \n    numVertices = sv;  \n                        \n    numEdges = 0;  \n                        \n    NodeTable = new Vertex[DefaultMaxVertices];  \n                                \n    if (NodeTable == nullptr) {  \n                                \n        memory_error(__func__, &quot;NodeTable&quot;);  \n                                \n    }  \n                        \n    for (int i = 0; i };  \n                        \nbool Graph_lnk::insertEdge(int v1, int v2, double weight) {  \n                                                \nif (v1 &gt;= 0 &amp;&amp; v1 = 0 &amp;&amp; v2 \n                                \n                        Edge * q = nullptr, * p = nullptr;  \n                        \n                        if (NodeTable[v1].adj != nullptr) {  \n                                \n                            p = NodeTable[v1].adj;  \n                        \n                            q = p - &gt; link;  \n                        \n                            while (q != nullptr) {  \n                                \n                                p = q;  \n                        \n                                q = p - &gt; link;  \n                        \n                            }  \n                        \n                            q = new Edge(v2, weight);  \n                                \n                            p - &gt; link = q;  \n                        \n                        } else {  \n                                \n                            NodeTable[v1].adj = new Edge(v2, weight);  \n                                \n                        }  \n                        \n                        if (NodeTable[v2].adj != nullptr) {  \n                                \n                            p = NodeTable[v2].adj;  \n                        \n                            q = p - &gt; link;  \n                        \n                            while (q != nullptr) {  \n                                \n                                p = q;  \n                        \n                                q = p - &gt; link;  \n                        \n                            }  \n                        \n                            q = new Edge(v1, weight);  \n                                \n                            p - &gt; link = q;  \n                        \n                        } else {  \n                                \n                            NodeTable[v2].adj = new Edge(v1, weight);  \n                                \n                        }  \n                        \n                        numEdges++;  \n                        \n                    }  \n                        \n                    return 0;  \n                                \n                }  \n                        \n                bool Graph_lnk::insertVertex(string data) {  \n                        \n                    if (numVertices == DefaultMaxVertices) return false;  \n                                                \n                    else {  \n                                \n                        NodeTable[numVertices].data = data;  \n                        \n                        NodeTable[numVertices].adj = nullptr;  \n                        \n                        numVertices++;  \n                        \n                    }  \n                        \n                    return true;  \n                                        \n                }  \n                        \n                    \n Graph_lnk::~Graph_lnk() {  \n                        \n    delete[] NodeTable;  \n                                \n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"分析与理由\"\u003E分析与理由\u003C\u002Fh2\u003E\n\u003Cp\u003E在交通道路网络图的构建中，一定需要的两个函数insertEdge();和insertVertex(); 我使用两个主要的数据结构，Edge（表示边），Vertex（表示点）。用它们的集合来表示整个图，这样做可以有效的利用空间？（但是还是申请了VerTex（500）） \n \u003C\u002Fp\u003E\n\u003Ch2 id=\"缺陷与不足\"\u003E缺陷与不足\u003C\u002Fh2\u003E\n\u003Cp\u003E不管你构建含多少个点的图，都需要申请固定的空间，只有当点小于而且越接近于500时空间利用率才最高。 \n插入边时，需要在两个点做增加，但是好像对于实际情况这样做并没有好处？ \n。。。。 \n \u003C\u002Fp\u003E\n\u003Ch2 id=\"问题与思考\"\u003E问题与思考\u003C\u002Fh2\u003E\n\u003Cp\u003E作为交通网络图，是否还需要拓展一些别的功能？ \n在储存的过程中，是否用bit矩阵来存储数据？ \n能不能在插入的过程中只新增一个点上的边？ \n或者直接以边为基本研究单位，来构建图类？ \u003C\u002Fp\u003E\n\u003Ch2 id=\"心得与感悟\"\u003E心得与感悟\u003C\u002Fh2\u003E\n\u003Cp\u003E本来以为写一个图类，会是一件比较容易的事，没想到却也花了这么久，是考虑的太多？还是基础不牢？ \n刚开始想用模板类来表示，这样在后期数据类型拓展时比较方便，没想到却是发现一堆错误，还解决不了，最后要重新来过。 \n基础还是要牢固才可以，现在写的东西自己都感觉境界不够，没有别人那种精妙绝伦的感觉。 \n平常有时间多沉下心来学习，切记好高骛远，绕了一圈最后发现自己什么都不行...\u003C\u002Fp\u003E\n"}],fetch:{},mutations:void 0});