__NUXT_JSONP__("/post/70", {data:[{article:"\u003C!--markdown--\u003E![2019-01-13 10-50-54屏幕截图.png][1]\n\u003Ch2 id=\"1-导入道路地图\"\u003E1. 导入道路地图\u003C\u002Fh2\u003E\n\u003Cp\u003E道路地图来自网络数据,已预处理为xml格式。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-xml\"\u003E&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;\n&lt;Roads&gt;\n  &lt;road m_ID=&quot;71283896--1&quot; len=&quot;620.98&quot;&gt;\n    &lt;from lon=&quot;113.9205606&quot; lat=&quot;22.9317667&quot; id=&quot;848388981&quot;\u002F&gt;\n    &lt;to lon=&quot;113.9260573&quot; lat=&quot;22.9341232&quot; id=&quot;2522072722&quot;\u002F&gt;\n  &lt;\u002Froad&gt;\n  &lt;road m_ID=&quot;553852656--2&quot; len=&quot;322.34&quot;&gt;\n    &lt;from lon=&quot;113.9529339&quot; lat=&quot;22.9448978&quot; id=&quot;5345735265&quot;\u002F&gt;\n    &lt;to lon=&quot;113.9516926&quot; lat=&quot;22.9475618&quot; id=&quot;5345735267&quot;\u002F&gt;\n  &lt;\u002Froad&gt;\n&lt;\u002FRoads&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E解析：一个road节点代表一条道路，len代表道路抽象长度，from，to子节点分别表示道路两端端点。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"2-解析道路数据\"\u003E2. 解析道路数据\u003C\u002Fh2\u003E\n\u003Ch3 id=\"a-构建交通图\"\u003Ea. 构建交通图\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E赋值道路端点.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-C++\"\u003E\u002F**\n*  路口类，记录着该路口的点坐标，以及其相连的方向道路节点组\n *               |           |\n *               |     |     |\n *               |  1     2  |\n *               |     |     |\n *        --------           --------\n *           3                  5\n *        - - - -            - - - -\n *           4                  6\n *        --------           --------\n *               |     |     |\n *               |  7     8  |\n *               |     |     |\n *               |           |\n *    如上图(1,2), (3,4), (5,6), (7,8)在同一个方向,我将其称为四组方向道路节点Node.\n *    其中,Node.inRoadID=1, Node.outRoadID=2;\n *         Node.inRoadID=4, Node.outRoadID=3;\n *         ...\n *         根据车辆靠右行原则以此类推.\n*\u002F\nclass CrossRoad {\npublic:\n    CrossRoad(float fLon,float fLat) : m_fLat(fLat),m_fLon(fLon){};\n    \u002F**\n     * 重载运算符 （==） 判断两个路口是否为同一个\n     *\u002F\n    bool operator==(CrossRoad &amp;crossRoad);\n    \u002F**\n     * 添加道路节点ID\n     * @param in 入度\n     * @param out 出度\n     * @param atan2 该点与方向道路的atan2值\n     *\u002F\n    void addNode(int in,int out,double atan2);\npublic:\n    \u002F\u002F唯一标示符\n    int m_nID;\n    \u002F\u002F经纬度的定义\n    float m_fLon, m_fLat;\n    vector&lt;Node&gt; JunctionRoad;\n    \u002F\u002F该路口的交通灯\n    TrafficLight m_CTrafficLight_Light;\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003ECrossRoad A,B\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E添加道路到交通图\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-C++\"\u003Evoid addRoad(Graph &amp;Map_Graph, CrossRoad A, CrossRoad B, double length) {\n    \u002F\u002F 初始化A，B路口的索引位置为-1\n    int CrossRoadSiteB = -1, CrossRoadSiteA = -1;\n    auto CrossRoadNum = Map_Graph.m_CrossRoad_v.size(), RoadNum = Map_Graph.m_Road_v.size();\n    \u002F\u002F循环判断是否有重合点\n    for (int i = 0; i &lt; CrossRoadNum; i++) {\n        if (Map_Graph.m_CrossRoad_v[i] == A) {\n            CrossRoadSiteA = i;\n        }\n        if (Map_Graph.m_CrossRoad_v[i] == B) {\n            CrossRoadSiteB = i;\n        }\n    }\n    \u002F\u002F如果不存在与A点重合的路口,添加路口，保存路口索引\n    if (CrossRoadSiteA == -1) {\n        Map_Graph.m_CrossRoad_v.push_back(A);\n        CrossRoadSiteA = CrossRoadNum++;\n        Map_Graph.m_CrossRoad_v[CrossRoadSiteA].m_nID = CrossRoadSiteA;\n    }\n    if (CrossRoadSiteB == -1) {\n        Map_Graph.m_CrossRoad_v.push_back(B);\n        CrossRoadSiteB = CrossRoadNum++;\n        Map_Graph.m_CrossRoad_v[CrossRoadSiteB].m_nID = CrossRoadSiteB;\n    }\n    int RoadSiteA = RoadNum, RoadSiteB = RoadNum + 1;\n    \u002F\u002F 确定A，B路的site，加入模型图\n    Road roadA(RoadSiteA, CrossRoadSiteA, CrossRoadSiteB, length);\n    Map_Graph.m_Road_v.push_back(roadA);\n    Road roadB(RoadSiteB, CrossRoadSiteB, CrossRoadSiteA, length);\n    Map_Graph.m_Road_v.push_back(roadB);\n    \u002F\u002F 对接A，B路口节点数据\n    Map_Graph.m_CrossRoad_v[CrossRoadSiteA].addNode(RoadSiteA, RoadSiteB,\n                                                    atan2((B.m_fLat - A.m_fLat), (B.m_fLon - A.m_fLon)));\n    Map_Graph.m_CrossRoad_v[CrossRoadSiteB].addNode(RoadSiteB, RoadSiteA,atan2((A.m_fLat - B.m_fLat), (A.m_fLon - B.m_fLon)));\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E解析的结果如下\n\u003Ca href=\"https:\u002F\u002Fwww.thinkmoon.cn\u002Fusr\u002Fuploads\u002F2019\u002F01\u002F2044047466.txt\"\u003Eroad.txt\u003C\u002Fa\u003E\n\u003Ca href=\"https:\u002F\u002Fwww.thinkmoon.cn\u002Fusr\u002Fuploads\u002F2019\u002F01\u002F4058503811.txt\"\u003ERoadTable.txt\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n"}],fetch:{},mutations:void 0});