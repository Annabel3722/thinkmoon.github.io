__NUXT_JSONP__("/post/145", {data:[{article:"\u003C!--markdown--\u003E```c++\n\u003Cp\u003ErunSimulation(Graph &amp;G)\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\n## 1. 遍历每条道路\n\n## 2. 遍历该道路的车辆\n\n### a. 计算特定时间间隔后的位置\n\n### b. 若应行驶至其他道路\n\n进入对应的路口缓冲区，根据路口类的红绿灯对象判断是否能通行。\n\n&gt; 若能通行，则填至目标道路\n&gt;\n&gt; 若不能，则继续停留在路口缓冲区\n\n### c. 若仍停留在原道路\n\n改变该车在当前道路的位置。\n\n```c++\n  for (auto &amp;road:G.m_Road_v) {\n        auto src = road.m_queVehicle;\n        decltype(road.m_queVehicle) obj;\n        \u002F\u002F路内车的遍历\n        while (!src.empty()) {\n            \u002F\u002F弹出一辆车\n            auto it = src.front();\n            src.pop_front();\n            \u002F\u002F 当车的时间戳小于实际时间时，才模拟运行\n            if (it.time &lt; SYSTEM_TIME) {\n                it.fSpec = (100 - road.get_Congestion() - 20) \u002F 3.6;\n                dist = it.dDistance + it.fSpec * 10;\n                it.time++;\n\n                it.showself();\n                \u002F\u002F如果车十秒后不在此路\n                if (dist &gt;= road.m_dLength) {\n                    \u002F\u002F路径擦除\n                    auto route = it.queRoute;\n                    int site = it.m_nSiteRoadID;\n                    route.pop();\n                    \u002F\u002F如果抵达终点\n                    if (route.empty()) {\n                        cout &lt;&lt; &quot;it is be shutdown&quot; &lt;&lt; endl;\n                        exit(0);\n                        \u002F\u002F 否侧没有抵达终点\n                    } else {\n                        \u002F\u002F获取所在路和下一条路的ID\n                        int next = route.front();\n                        \u002F\u002F判断红绿灯情况\n                        cout &lt;&lt; site &lt;&lt; endl;\n                        G.m_CrossRoad_v[site].m_CTrafficLight_Light.clock(SYSTEM_TIME);\n                        \u002F\u002F如果可以通行\n                        if (G.m_CrossRoad_v[site].m_CTrafficLight_Light.getStatus(it.m_nSiteRoadID, next)) {\n                            cout &lt;&lt; GREEN &lt;&lt; &quot;绿灯通行:&quot; &lt;&lt; endl;\n                            it.queRoute = route;\n                            it.dDistance = 0;\n                            it.m_nSiteRoadID = next;\n                            auto *site_road = &amp;G.m_Road_v[next].m_queVehicle;\n                            site_road-&gt;push_back(it);\n                            \u002F\u002F如果不能通行\n                        } else {\n                            \u002F\u002F将距离置为道路长度，表示正在等候红灯\n                            it.dDistance = G.m_Road_v[it.m_nSiteRoadID].m_dLength;\n                            cout &lt;&lt; YELLOW &lt;&lt; &quot;等待红灯&quot; &lt;&lt; endl;\n                            \u002F\u002F车辆塞回去\n                            obj.push_back(it);\n                        }\n                    }\n                    \u002F\u002F否则，当车十秒后还在此路时\n                } else {\n                    it.dDistance = dist;\n                    obj.push_back(it);\n                }\n                \u002F\u002F否则直接填入\n            } else {\n                obj.push_back(it);\n            }\n        }\n        road.m_queVehicle = obj;\n    }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"}],fetch:{},mutations:void 0});