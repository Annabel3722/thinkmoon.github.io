__NUXT_JSONP__("/post/77", {data:[{article:"\u003Cblockquote\u003E\n\u003Cp\u003EC++11引入了auto和decltype关键字实现类型推导，通过这两个关键字不仅能方便地获得复杂的类型，还能简化书写，提高编码效率。下面说一下C++中的auto\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"旧标准\"\u003E旧标准\u003C\u002Fh3\u003E\n\u003Cp\u003Eauto其实并不是一个新的关键字，在旧的标准C++98\u002F03中，它代表着“具有自动存储周期的局部变量”。啥意思呢？就是我们平常所说的变量，他与static相对。就是说所有非static类型的都是“具有自动存储期的”。也就是说在旧的标准下。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-C++\"\u003Eautoint i =3;\u002F\u002F等价于int i=3;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"新标准\"\u003E新标准\u003C\u002Fh3\u003E\n\u003Cp\u003E在C++11中，auto作为一个新的类型指示符（如int，double）来指示编译器的，但是auto申明的变量的类型必须由编译器在编译时期推导出来，也称类型推导。这种类型推导不是C++所独有的，还有很多具备这种能力的语言（如Python，Javascript）。我们先来看一段Python代码\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-python\"\u003Ename =&quot;thinkmoon&quot;print&quot;hello,&quot;+ name \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在这里的name是不需要定义类型的，因为这个类型很容易被推导为字符串性，如过要想在C++中实现这种效果，我们可以这样。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-C++\"\u003E#include&lt;iostream&gt;\nint main(){\n    auto name =&quot;thinkmoon&quot;; \n    std::cout &lt;&lt;&quot;hello,&quot;&lt;&lt; name &lt;&lt; std::endl;\n    return0;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E效果是一样的，是不是觉得写起来特别的方便呢？\u003C\u002Fp\u003E\n\u003Cp\u003E但是需要注意的是，在C++中这种静态类型推导是发生在编译期间的。而像Python这种动态类型推导却是发生在运行期间的。\u003C\u002Fp\u003E\n\u003Ch3 id=\"auto的基本用法\"\u003Eauto的基本用法\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-C++\"\u003E#include&lt;iostream&gt;\nusingnamespace std;\nint main(){\nauto x =5; \ncout &lt;&lt; x &lt;&lt; endl;\u002F\u002Fx被推导为intauto p =newauto(1);    \ncout &lt;&lt;&quot;*&quot;&lt;&lt; p &lt;&lt;&quot;=&quot;&lt;&lt;*p &lt;&lt; endl;\u002F\u002Fp被推导为\nint *constauto*v =&amp;x, u =6; \ncout &lt;&lt;&quot;*&quot;&lt;&lt; v &lt;&lt;&quot;=&quot;&lt;&lt;*v &lt;&lt;&quot;\\n u=&quot;&lt;&lt; u &lt;&lt; endl;\u002F\u002Fv被推导为const int *，u被推导const int\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E对于最后一个类型推导有几个需要注意\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E v被推导为const int *而这里auto代替int，但是u等于6还是要写的，否则编译器会报错。\u003C\u002Fli\u003E\n\u003Cli\u003E u的等号后面只能写整型的变量，否则会报错，因为不能让编译器产生具有二义性的推断。\u003Cblockquote\u003E\n\u003Cp\u003E其实我们学习的时候可以把auto理解为占位符，它只是占着一个位置并不做其它的事情，由编译器将其类型推导出来再用对应的类型去运行，所以这个时候auto的类型推导是不能让编译器产生二义性的。  \u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"auto的推导规则\"\u003Eauto的推导规则\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-C++\"\u003Eint x =0;auto* a =&amp;x;\u002F\u002Fauto推导为int，\nauto b =&amp;x;\u002F\u002Fauto推导为int *，即使不申明为指针也能推断为指针\nauto&amp; c = x;\u002F\u002Fauto推导为int，等价于int \nauto d = c;\u002F\u002Fauto推导为int，auto会抛弃右值的引用类型\nconst auto e = x;\u002F\u002Fe是const int类型，\nauto f = e;\u002F\u002Ff是int型constauto&amp;g = x;\u002F\u002Fg是const \nint &amp; auto &amp; h = g;  \u002F\u002Fh是const int &amp; \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E总结：\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Col\u003E\n\u003Cli\u003E 当不申明为引用或者指针时，auto的推导规则会抛弃对应右值的cv限定符（cv-qualifier，const，volatile限定符的总称）。\u003C\u002Fli\u003E\n\u003Cli\u003E 当申明为引用或者指针时，auto推导规则会保留右值的cv属性。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"auto的限制\"\u003Eauto的限制\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E auto s\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E错误原因:s没有明确的类型，auto无法推断。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E void fun(auto a=1){….}\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E错误原因：auto类型推导不能用作函数参数。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E auto不能用于非静态成员函数\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-C++\"\u003Estruct Foo\n{\n    auto var_1=0;\u002F\u002F错误，auto不能用于非静态成员函数\n    static const auto var_2=0;\u002F\u002FOK，var_2为static const int\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"4--auto无法定义数组\"\u003E4.  auto无法定义数组\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode\u003Eint main()\n{\n    int arr[10]={0};\n    auto aa    = arr; \u002F\u002FOK,aa为int *\n    auto bb[10]=arr;\u002F\u002Ferror,auto无法定义数组\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"5--auto无法推导出模板参数\"\u003E5.  auto无法推导出模板参数\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-C++\"\u003EBar&lt;int&gt; bar;\nBar&lt;auto&gt; bb = bar;\u002F\u002Ferror,auto无法推导出模板参数\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"auto的优势\"\u003Eauto的优势\u003C\u002Fh3\u003E\n\u003Cp\u003E既然auto的功能特性这么方便，那么它的优势在哪？或者说，我们什么时候使用它能达到神效呢？\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E 遍历vector\u003Cblockquote\u003E\n\u003Cp\u003E这是一个简单的遍历。\n\u003Ccode\u003Evector&lt;int&gt; vs;for(auto i = vs.begin(); i &lt; vs.end(); i++){......}\u003C\u002Fcode\u003E\n其实还可以更简单\n\u003Ccode\u003Efor(auto var : vs){.......}\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E 待补充。。。。。。。嘿嘿！\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"}],fetch:{},mutations:void 0});