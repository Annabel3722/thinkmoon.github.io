__NUXT_JSONP__("/post/219", {data:[{article:"\u003Cblockquote\u003E\n\u003Cp\u003E想达到本文效果，需使用wepy框架。不了解wepy？转\u003Ca href=\"https:\u002F\u002Ftencent.github.io\u002Fwepy\u002Findex.html\"\u003Ehttps:\u002F\u002Ftencent.github.io\u002Fwepy\u002Findex.html\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"什么是asyncawait\"\u003E什么是async\u002Fawait?\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E在最新的ES7（ES2017）中提出的前端异步特性：async、await。\nasync顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成。也就是我们平常所说的异步等待。不过需注意\u003Ccode\u003Eawait只能在async函数中使用\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"为什么需要asyncawait\"\u003E为什么需要async\u002Fawait?\u003C\u002Fh2\u003E\n\u003Cp\u003E在async\u002Fawait之前，我们有三种方式写异步代码\u003C\u002Fp\u003E\n\u003Ch3 id=\"1-嵌套回调\"\u003E1. 嵌套回调\u003C\u002Fh3\u003E\n\u003Cp\u003E其中思想就是,a函数执行完了得到的结果后在执行b。\n形如\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Ewx.getSetting({\n      success(res) {\n        console.log(res.authSetting[&#39;scope.userLocation&#39;]);\n        if (!res.authSetting[&#39;scope.userLocation&#39;]) {\n          wx.authorize({\n            scope: &#39;scope.userLocation&#39;,\n            fail(res) {\n              Toast(&#39;无法获取位置,采用默认排序&#39;);\n            }\n          });\n        } else {\n          wx.getLocation({\n            type: &#39;wgs84&#39;,\n            success(res) {\n              _this.setData({ location: res });\n              console.log(&#39;您的位置信息:&#39;, res);\n            },\n            fail() {\n              Toast(&#39;无法获取位置,采用默认排序&#39;);\n            }\n          });\n        }\n      }\n    });\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E上面的代码你不用看，就会感觉。这啥东西？乱七八糟的。这就是嵌套回调。很不巧，原生微信小程序开发就是这样的。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"2-以promise为主的链式回调\"\u003E2. 以Promise为主的链式回调\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。形如\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Evar p1 = new Promise((resolve, reject) =&gt; {\n setTimeout(resolve, 1000, &#39;done&#39;);\n })\np1.then(data=&gt;{\n console.log(data); \u002F\u002F done\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果你的函数够多的话，那么就会一直then()下去。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E为了优雅，Promise提供了一个方法\u003Ccode\u003EPromise.all([p1,p2,p3])\u003C\u002Fcode\u003E ，用于将多个Promise实例，包装成一个新的Promise实例。接收的参数是一个数组,p1、p2、p3都是Promise对象\n分两种情况：\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Col\u003E\n\u003Cli\u003Ep1、p2、p3的状态都是resolve的时候，Promise.all的状态才会变成resolve；\u003C\u002Fli\u003E\n\u003Cli\u003E只要p1、p2、p3中有一个的状态为reject，那么Promise.all的状态就会变成reject；\n所以我们可以用Promise.all()来解决多个异步依赖调用。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"3-使用generators\"\u003E3. 使用Generators\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Efunction *main() {\n    var x = yield 1;\n    var y = yield x;\n    var z = yield (y * 2);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E上面代码中的每一条语句都会按顺序一个一个地执行。Yield关键字标明了代码中被阻塞的点（只能被generator函数自己阻塞，外部代码不能阻塞generator函数的执行），但是不会改变*main()函数中代码的执行顺序。这段代码很简单！\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E但是，这三种写起来都还是不够优雅，ES7做了优化改进，async\u002Fawait应运而生，async\u002Fawait相比较Promise 对象then 函数的嵌套，与 Generator 执行的繁琐(需要借助co才能自动执行，否则得手动调用next())， Async\u002FAwait 可以让你轻松写出同步风格的代码同时又拥有异步机制，更加简洁，逻辑更加清晰。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E示例\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Easync a(){};\nconst b = await a();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"这样做的好处？\"\u003E这样做的好处？\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E唔，你不觉得一个优雅的代码就该是这样吗？好吧，其实这样更容易符合我们平常的思维逻辑\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"回到本文的题目\"\u003E回到本文的题目\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E在wepy1.4.1以后的版本（之前的版本都是默认开启的），默认不支持async\u002Fawait，需要用户手动加入，方法如下：\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"进入项目根目录，安装runtime包\"\u003E进入项目根目录，安装runtime包\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode\u003Enpm install wepy-async-function --save\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"修改wepyconfigjs加入runtime配置\"\u003E修改wepy.config.js加入runtime配置\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode\u003E        babel: {\n            &quot;presets&quot;: [\n                &quot;env&quot;\n            ],\n            &quot;plugins&quot;: [\n                &quot;transform-export-extensions&quot;,\n                &quot;syntax-export-extensions&quot;\n            ]\n        }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"在appwpy中引入引入runtime包\"\u003E在app.wpy中引入引入runtime包\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode\u003Eimport &#39;wepy-async-function&#39;; \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"在appwpy中使api-promise化\"\u003E在app.wpy中使API promise化\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E重写构造函数，使其支持async\u002Fawait。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cpre\u003E\u003Ccode\u003Eexport default class extends wepy.app {\n    constructor () {\n        super();\n        this.use(&#39;promisify&#39;);\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"重启编译\"\u003E重启编译\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode\u003Ewepy build --no-cache\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"使用示例\"\u003E使用示例\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E在wepy框架官方文档中已说明，对所有的微信小程序都支持async\u002Fawait操作。只需将形如\u003Ccode\u003Ewx.getuserInfo\u003C\u002Fcode\u003E改写为\u003Ccode\u003Ewepy.getuserInfo\u003C\u002Fcode\u003E即可\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cpre\u003E\u003Ccode\u003Easync userInfoAsync() {\n    const _this = this;\n    const data = await wepy.getSetting(); \u002F\u002F获取设置数据\n    if (data.authSetting[&#39;scope.userInfo&#39;]) { \u002F\u002F判断是否有获取用户信息的权限\n      await wepy.login(); \u002F\u002F登录\n      let data = await wepy.getUserInfo();\u002F\u002F获取用户信息\n      _this.userInfo = data.userInfo;\u002F\u002F采用wepy框架修改过后的功能，支持直接赋值数据绑定\n      _this.$apply(); \u002F\u002F在async的函数中，必须主动执行`$apply()`来进行脏数据检查\n    }\n  }\nasync onShow() {\n    this.userInfoAsync(); \u002F\u002F调用async函数\n  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E以上代码实现了异步同步用户userInfo的功能\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E参考文献:\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.jb51.net\u002Farticle\u002F103068.htm\"\u003E使用Promise链式调用解决多个异步回调的问题\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblog.csdn.net\u002Fsamt007\u002Farticle\u002Fdetails\u002F54647361\"\u003E关于js的callback回调函数以及嵌套回调函数的执行过程理解\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.cnblogs.com\u002Fjaxu\u002Fp\u002F6592210.html\"\u003EES6 Generators并发\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.cnblogs.com\u002FleungUwah\u002Fp\u002F7932912.html\"\u003EES7前端异步玩法：async\u002Fawait理解\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fsegmentfault.com\u002Fa\u002F1190000007535316?utm_source=tag-newest\"\u003E理解 JavaScript 的 async\u002Fawait\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fsegmentfault.com\u002Fa\u002F1190000013292562?utm_source=channel-newest\"\u003EAsync\u002Fawait学习\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.jianshu.com\u002Fp\u002F1e75bd387aa0\"\u003E浅谈async\u002Fawait\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FTencent\u002Fwepy\u002Fwiki\u002Fwepy%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8async-await\"\u003Ewepy项目中使用async await\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"}],fetch:{},mutations:void 0});