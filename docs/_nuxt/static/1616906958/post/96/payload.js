__NUXT_JSONP__("/post/96", {data:[{article:"\u003Ch2 id=\"简单的python版本管理器-pyenv\"\u003E简单的python版本管理器: pyenv\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003Epyenv可以让你轻松的在各版本的python环境中切换自如，它是一个简单而又不引人注目并遵循UNIX传统的专用工具。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E这个项目是从\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Frbenv\u002Frbenv\"\u003Erbenv\u003C\u002Fa\u003E和\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Frbenv\u002Fruby-build\"\u003Eruby-build\u003C\u002Fa\u003Efork而来, 并且在配合Python的情况下做了适当的修改.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fblog.cdn.thinkmoon.cn\u002Fblog\u002Ftypecho\u002F2019-09-03T02:26:51.png\" alt=\"Terminal output example\"\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"pyenv能做什么？\"\u003Epyenv能做什么？\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E让你在\u003Cstrong\u003E用户基础\u003C\u002Fstrong\u003E上改变全局Python版本.\u003C\u002Fli\u003E\n\u003Cli\u003E支持为\u003Cstrong\u003E每一个项目\u003C\u002Fstrong\u003E设立一个Python版本.\u003C\u002Fli\u003E\n\u003Cli\u003E允许您使用\u003Cstrong\u003E环境变量\u003C\u002Fstrong\u003E覆盖Python版本.\u003C\u002Fli\u003E\n\u003Cli\u003E在\u003Cstrong\u003E多个python环境\u003C\u002Fstrong\u003E中搜索命令,这有助于在Python版本中进行测试 \u003Ca href=\"https:\u002F\u002Fpypi.python.org\u002Fpypi\u002Ftox\"\u003Etox\u003C\u002Fa\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"与pythonbrew和pythonz相比，pyenv不能做什么\"\u003E与pythonbrew和pythonz相比，pyenv不能做什么?\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E不依赖于Python本身。\u003C\u002Fstrong\u003E pyenv是由纯shell脚本制作的。没有Python的引导问题。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E不需要加载到你的shell中。\u003C\u002Fstrong\u003E相反，pyenv的shim方法的工作原理是在\u003Ccode\u003E$ PATH\u003C\u002Fcode\u003E中添加一个目录。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E不能管理virtualenv\u003C\u002Fstrong\u003E 当然你可以自行创建virtualenv \u003Ca href=\"https:\u002F\u002Fpypi.python.org\u002Fpypi\u002Fvirtualenv\"\u003Evirtualenv\u003C\u002Fa\u003E或者使用\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv-virtualenv\"\u003Epyenv-virtualenv\u003C\u002Fa\u003E去自动化构建\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"工作原理\"\u003E工作原理\u003C\u002Fh2\u003E\n\u003Cp\u003E在较高的层次上，pyenv使用shim拦截Python命令注入\u003Ccode\u003EPATH\u003C\u002Fcode\u003E的可执行文件, 确定哪个Python版本已由您的应用程序指定，并传递您的命令使用你想要的Python安装版本。\u003C\u002Fp\u003E\n\u003Ch3 id=\"理解path环境变量路径\"\u003E理解PATH(环境变量路径)\u003C\u002Fh3\u003E\n\u003Cp\u003E当你执行命令,如\u003Ccode\u003Epython\u003C\u002Fcode\u003E或者\u003Ccode\u003Epip\u003C\u002Fcode\u003E, 你的操作系统会搜索目录列表以查找可执行文件的那个名字.此目录列表位于环境变量中称为\u003Ccode\u003EPATH\u003C\u002Fcode\u003E, 列表中的每个目录使用用冒号分隔.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fwww.thinkmoon.cn\u002Fusr\u002Fuploads\u002F2019\u002F01\u002F1698659685.png\" alt=\"PATH.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EPATH\u003C\u002Fcode\u003E中的目录从左到右搜索，因此首先匹配在列表开头的目录中的可执行文件, 然后一次往右匹配。在这个例子中，首先搜索\u003Ccode\u003E\u002Fusr\u002Flocal\u002Fsbin\u003C\u002Fcode\u003E目录，然后搜索\u003Ccode\u003E\u002Fusr\u002Flocal\u002Fbin\u003C\u002Fcode\u003E，然后是\u003Ccode\u003E\u002Fusr\u002Fsbin\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Ch3 id=\"理解shims垫片\"\u003E理解Shims(垫片)\u003C\u002Fh3\u003E\n\u003Cp\u003Epyenv的工作原理是在你的\u003Ccode\u003EPATH\u003C\u002Fcode\u003E前面插入一个shims目录，这样一来系统在搜索Python的时候第一个找到的就是pyenv管理的Python环境。这个插到最前面的路径就叫做垫片（shims）\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E$(pyenv root)\u002Fshims:\u002Fusr\u002Flocal\u002Fbin:\u002Fusr\u002Fbin:\u002Fbin\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E通过一个叫做为_rehashing_的进程, pyenv维护shims目录以匹配每个已安装版本的每个Python命令,比如\u003Ccode\u003Epython\u003C\u002Fcode\u003E，\u003Ccode\u003Epip\u003C\u002Fcode\u003E等。\u003C\u002Fp\u003E\n\u003Cp\u003E垫片是轻量级可执行文件，只是简单地传递命令到pyenv。所以只要安装了pyenv，当你运行时，比如说，\u003Ccode\u003Epip\u003C\u002Fcode\u003E，你的操作系统将执行以下操作：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E在\u003Ccode\u003EPATH\u003C\u002Fcode\u003E中搜索名为\u003Ccode\u003Epip\u003C\u002Fcode\u003E的可执行文件\u003C\u002Fli\u003E\n\u003Cli\u003E在\u003Ccode\u003EPATH\u003C\u002Fcode\u003E的开头找到名为\u003Ccode\u003Epip\u003C\u002Fcode\u003E的pyenv垫片\u003C\u002Fli\u003E\n\u003Cli\u003E运行名为\u003Ccode\u003Epip\u003C\u002Fcode\u003E的垫片，然后将命令传递给属于pyenv的pip命令\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"选择python版本\"\u003E选择Python版本\u003C\u002Fh3\u003E\n\u003Cp\u003E执行shims程序时，pyenv会确定要使用的Python版本,并按此以下资源顺序读取:\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EPYENV_VERSION\u003C\u002Fcode\u003E环境变量（如果指定）. 你可以使用\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fblob\u002Fmaster\u002FCOMMANDS.md#pyenv-shell\"\u003E\u003Ccode\u003Epyenv shell\u003C\u002Fcode\u003E\u003C\u002Fa\u003E 去设置环境变量在你当前shell session.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E当前特定于应用程序的\u003Ccode\u003E.python-version\u003C\u002Fcode\u003E文件目录（如果有）. 您可以使用 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fblob\u002Fmaster\u002FCOMMANDS.md#pyenv-local\"\u003E\u003Ccode\u003Epyenv local\u003C\u002Fcode\u003E\u003C\u002Fa\u003E修改当前目录\u003Ccode\u003E.python-version\u003C\u002Fcode\u003E文件.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E通过搜索每个上层目录,找到第一个\u003Ccode\u003E.python-version\u003C\u002Fcode\u003E文件（如果有的话），直到到达文件系统的根目录\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E全局\u003Ccode\u003E$(pyenv root)\u002Fversion\u003C\u002Fcode\u003E文件. 您可以使用\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fblob\u002Fmaster\u002FCOMMANDS.md#pyenv-global\"\u003E\u003Ccode\u003Epyenv global\u003C\u002Fcode\u003E\u003C\u002Fa\u003E 修改这个文件. 如果是该全局文件不存在，pyenv假设您要使用“系统”Python。(换句话说，如果pyenv不在您的PATH中，那么任何版本都会运行.)\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cstrong\u003ENOTE:\u003C\u002Fstrong\u003E 您可以同时激活多个版本，甚至包括Python2或Python3的任何版本. 这允许平行使用Python2和Python3，并且需要像\u003Ccode\u003Etox\u003C\u002Fcode\u003E这样的工具. 例如，要设置你的首次使用的系统Python和Python3的路径（在这个例子中设置为2.7.9和3.4.2），但也可以在你的\u003Ccode\u003EPATH\u003C\u002Fcode\u003E使用Python 3.3.6,3.2和2.5，首先是\u003Ccode\u003Epyenv install\u003C\u002Fcode\u003E缺少的版本，然后设置\u003Ccode\u003Epyenv\u003C\u002Fcode\u003E全局3.3.6 3.2 2.5\u003Ccode\u003E.这时, 使用\u003C\u002Fcode\u003Epyenv which\u003Ccode\u003E应该能够找到每个可执行路径, 例如\u003C\u002Fcode\u003Epyenv which python2.5\u003Ccode\u003E（应该显示\u003C\u002Fcode\u003E$（pyenv root\u002Fversions\u002F2.5 \u002Fbin\u002Fpython2.5\u003Ccode\u003E) 或者\u003C\u002Fcode\u003Epyenv which python3.4\u003Ccode\u003E(应该显示系统Python3路径). 您还可以指定多个\u003C\u002Fcode\u003E.python-version`文件中的版本，由换行符或任何空格分隔。\u003C\u002Fp\u003E\n\u003Ch3 id=\"定位python的安装路径\"\u003E定位Python的安装路径\u003C\u002Fh3\u003E\n\u003Cp\u003E一旦pyenv确定了您的应用程序具有哪个版本的Python, 它将命令传递给相应的Python.\u003C\u002Fp\u003E\n\u003Cp\u003E每个Python版本都安装在自己的目录下\n\u003Ccode\u003E$(pyenv root)\u002Fversions\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003E例如，您可能安装了这些版本:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003E$(pyenv root)\u002Fversions\u002F2.7.8\u002F\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E$(pyenv root)\u002Fversions\u002F3.4.2\u002F\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E$(pyenv root)\u002Fversions\u002Fpypy-2.4.0\u002F\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E就pyenv而言，版本名称只是其中的目录名\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003E$(pyenv root)\u002Fversions\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Ch3 id=\"管理虚拟环境\"\u003E管理虚拟环境\u003C\u002Fh3\u003E\n\u003Cp\u003E有一个叫做\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv-virtualenv\"\u003Epyenv-virtualenv\u003C\u002Fa\u003E的pyenv插件, 它有很多功能，可帮助pyenv用户管理virtualenv或Anaconda创建的虚拟环境。因为那些虚拟环境的\u003Ccode\u003Eactivate\u003C\u002Fcode\u003E脚本依赖于改变shell的\u003Ccode\u003E$ PATH\u003C\u002Fcode\u003E变量, \n它会去hook拦截pyenv的shim样式命令钩子.如果您有计划使用这些虚拟环境，我们建议您安装pyenv-virtualenv。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"安装\"\u003E安装\u003C\u002Fh2\u003E\n\u003Cp\u003E如果您是macOS,推荐转至\u003Ca href=\"#homebrew-on-macos\"\u003Einstalling with Homebrew\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Ch3 id=\"自动化安装器\"\u003E自动化安装器\u003C\u002Fh3\u003E\n\u003Cp\u003E访问以下项目:\n\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv-installer\"\u003Ehttps:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv-installer\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"基于github检出\"\u003E基于GitHub检出\u003C\u002Fh3\u003E\n\u003Cp\u003E这可以让你一直保持最新版本的pyenv, 并且fork上游分支的任何变化\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003E在哪里检出.\u003C\u002Fstrong\u003E\n我们建议\u003Ccode\u003E$HOME\u002F.pyenv\u003C\u002Fcode\u003E (但其实您可以安装在任何地方).\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E $ git clone https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv.git ~\u002F.pyenv\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EDefine environment variable \u003Ccode\u003EPYENV_ROOT\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E to point to the path where\npyenv repo is cloned and add \u003Ccode\u003E$PYENV_ROOT\u002Fbin\u003C\u002Fcode\u003E to your \u003Ccode\u003E$PATH\u003C\u002Fcode\u003E for access\nto the \u003Ccode\u003Epyenv\u003C\u002Fcode\u003E command-line utility.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-sh\"\u003E$ echo &#39;export PYENV_ROOT=&quot;$HOME\u002F.pyenv&quot;&#39; &gt;&gt; ~\u002F.bash_profile\n$ echo &#39;export PATH=&quot;$PYENV_ROOT\u002Fbin:$PATH&quot;&#39; &gt;&gt; ~\u002F.bash_profile\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E \u003Cstrong\u003EZsh note\u003C\u002Fstrong\u003E: Modify your \u003Ccode\u003E~\u002F.zshenv\u003C\u002Fcode\u003E file instead of \u003Ccode\u003E~\u002F.bash_profile\u003C\u002Fcode\u003E.\n \u003Cstrong\u003EUbuntu and Fedora note\u003C\u002Fstrong\u003E: Modify your \u003Ccode\u003E~\u002F.bashrc\u003C\u002Fcode\u003E file instead of \u003Ccode\u003E~\u002F.bash_profile\u003C\u002Fcode\u003E.\n \u003Cstrong\u003EProxy note\u003C\u002Fstrong\u003E: If you use a proxy, export \u003Ccode\u003Ehttp_proxy\u003C\u002Fcode\u003E and \u003Ccode\u003EHTTPS_PROXY\u003C\u002Fcode\u003E too.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EAdd \u003Ccode\u003Epyenv init\u003C\u002Fcode\u003E to your shell\u003C\u002Fstrong\u003E to enable shims and autocompletion.\nPlease make sure \u003Ccode\u003Eeval &quot;$(pyenv init -)&quot;\u003C\u002Fcode\u003E is placed toward the end of the shell\nconfiguration file since it manipulates \u003Ccode\u003EPATH\u003C\u002Fcode\u003E during the initialization.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-sh\"\u003E$ echo -e &#39;if command -v pyenv 1&gt;\u002Fdev\u002Fnull 2&gt;&amp;1; then\\n  eval &quot;$(pyenv init -)&quot;\\nfi&#39; &gt;&gt; ~\u002F.bash_profile\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003EZsh note\u003C\u002Fstrong\u003E: Modify your \u003Ccode\u003E~\u002F.zshenv\u003C\u002Fcode\u003E file instead of \u003Ccode\u003E~\u002F.bash_profile\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003Efish note\u003C\u002Fstrong\u003E: Use \u003Ccode\u003Epyenv init - | source\u003C\u002Fcode\u003E instead of \u003Ccode\u003Eeval (pyenv init -)\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EUbuntu and Fedora note\u003C\u002Fstrong\u003E: Modify your \u003Ccode\u003E~\u002F.bashrc\u003C\u002Fcode\u003E file instead of \u003Ccode\u003E~\u002F.bash_profile\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E \u003Cstrong\u003EGeneral warning\u003C\u002Fstrong\u003E: There are some systems where the \u003Ccode\u003EBASH_ENV\u003C\u002Fcode\u003E variable is configured\n to point to \u003Ccode\u003E.bashrc\u003C\u002Fcode\u003E. On such systems you should almost certainly put the abovementioned line\n \u003Ccode\u003Eeval &quot;$(pyenv init -)&quot;\u003C\u002Fcode\u003E into \u003Ccode\u003E.bash_profile\u003C\u002Fcode\u003E, and \u003Cstrong\u003Enot\u003C\u002Fstrong\u003E into \u003Ccode\u003E.bashrc\u003C\u002Fcode\u003E. Otherwise you\n may observe strange behaviour, such as \u003Ccode\u003Epyenv\u003C\u002Fcode\u003E getting into an infinite loop.\n See \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fissues\u002F264\"\u003E#264\u003C\u002Fa\u003E for details.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003ERestart your shell so the path changes take effect.\u003C\u002Fstrong\u003E\nYou can now begin using pyenv.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-sh\"\u003E$ exec &quot;$SHELL&quot;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EInstall Python build dependencies\u003C\u002Fstrong\u003E before attempting to install a new Python version.  The\n\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fwiki\"\u003Epyenv wiki\u003C\u002Fa\u003E provides suggested installation packages\nand commands for various operating systems.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EInstall Python versions into \u003Ccode\u003E$(pyenv root)\u002Fversions\u003C\u002Fcode\u003E.\u003C\u002Fstrong\u003E\nFor example, to download and install Python 2.7.8, run:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-sh\"\u003E$ pyenv install 2.7.8\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003ENOTE:\u003C\u002Fstrong\u003E If you need to pass configure option to build, please use\n\u003Ccode\u003ECONFIGURE_OPTS\u003C\u002Fcode\u003E environment variable.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003ENOTE:\u003C\u002Fstrong\u003E If you want to use proxy to download, please use \u003Ccode\u003Ehttp_proxy\u003C\u002Fcode\u003E and \u003Ccode\u003Ehttps_proxy\u003C\u002Fcode\u003E\nenvironment variable.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003ENOTE:\u003C\u002Fstrong\u003E If you are having trouble installing a python version,\nplease visit the wiki page about\n\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fwiki\u002FCommon-build-problems\"\u003ECommon Build Problems\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch4 id=\"upgrading\"\u003EUpgrading\u003C\u002Fh4\u003E\n\u003Cp\u003EIf you&#39;ve installed pyenv using the instructions above, you can\nupgrade your installation at any time using git.\u003C\u002Fp\u003E\n\u003Cp\u003ETo upgrade to the latest development version of pyenv, use \u003Ccode\u003Egit pull\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-sh\"\u003E$ cd $(pyenv root)\n$ git pull\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ETo upgrade to a specific release of pyenv, check out the corresponding tag:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-sh\"\u003E$ cd $(pyenv root)\n$ git fetch\n$ git tag\nv0.1.0\n$ git checkout v0.1.0\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"uninstalling-pyenv\"\u003EUninstalling pyenv\u003C\u002Fh3\u003E\n\u003Cp\u003EThe simplicity of pyenv makes it easy to temporarily disable it, or\nuninstall from the system.\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003ETo \u003Cstrong\u003Edisable\u003C\u002Fstrong\u003E pyenv managing your Python versions, simply remove the\n\u003Ccode\u003Epyenv init\u003C\u002Fcode\u003E line from your shell startup configuration. This will\nremove pyenv shims directory from PATH, and future invocations like\n\u003Ccode\u003Epython\u003C\u002Fcode\u003E will execute the system Python version, as before pyenv.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Epyenv\u003C\u002Fcode\u003E will still be accessible on the command line, but your Python\napps won&#39;t be affected by version switching.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003ETo completely \u003Cstrong\u003Euninstall\u003C\u002Fstrong\u003E pyenv, perform step (1) and then remove\nits root directory. This will \u003Cstrong\u003Edelete all Python versions\u003C\u002Fstrong\u003E that were\ninstalled under \u003Ccode\u003E$(pyenv root)\u002Fversions\u002F\u003C\u002Fcode\u003E directory:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-sh\"\u003Erm -rf $(pyenv root)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EIf you&#39;ve installed pyenv using a package manager, as a final step\nperform the pyenv package removal. For instance, for Homebrew:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E brew uninstall pyenv\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"homebrew-on-macos\"\u003EHomebrew on macOS\u003C\u002Fh3\u003E\n\u003Cp\u003EYou can also install pyenv using the \u003Ca href=\"https:\u002F\u002Fbrew.sh\"\u003EHomebrew\u003C\u002Fa\u003E\npackage manager for macOS.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E$ brew update\n$ brew install pyenv\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ETo upgrade pyenv in the future, use \u003Ccode\u003Eupgrade\u003C\u002Fcode\u003E instead of \u003Ccode\u003Einstall\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EThen follow the rest of the post-installation steps under \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv#basic-github-checkout\"\u003EBasic GitHub Checkout\u003C\u002Fa\u003E above, starting with #3 (&quot;Add \u003Ccode\u003Epyenv init\u003C\u002Fcode\u003E to your shell to enable shims and autocompletion&quot;).\u003C\u002Fp\u003E\n\u003Ch3 id=\"advanced-configuration\"\u003EAdvanced Configuration\u003C\u002Fh3\u003E\n\u003Cp\u003ESkip this section unless you must know what every line in your shell\nprofile is doing.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Epyenv init\u003C\u002Fcode\u003E is the only command that crosses the line of loading\nextra commands into your shell. Coming from rvm, some of you might be\nopposed to this idea. Here&#39;s what \u003Ccode\u003Epyenv init\u003C\u002Fcode\u003E actually does:\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003ESets up your shims path.\u003C\u002Fstrong\u003E This is the only requirement for pyenv to\nfunction properly. You can do this by hand by prepending\n\u003Ccode\u003E$(pyenv root)\u002Fshims\u003C\u002Fcode\u003E to your \u003Ccode\u003E$PATH\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EInstalls autocompletion.\u003C\u002Fstrong\u003E This is entirely optional but pretty\nuseful. Sourcing \u003Ccode\u003E$(pyenv root)\u002Fcompletions\u002Fpyenv.bash\u003C\u002Fcode\u003E will set that\nup. There is also a \u003Ccode\u003E$(pyenv root)\u002Fcompletions\u002Fpyenv.zsh\u003C\u002Fcode\u003E for Zsh\nusers.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003ERehashes shims.\u003C\u002Fstrong\u003E From time to time you&#39;ll need to rebuild your\nshim files. Doing this on init makes sure everything is up to\ndate. You can always run \u003Ccode\u003Epyenv rehash\u003C\u002Fcode\u003E manually.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EInstalls the sh dispatcher.\u003C\u002Fstrong\u003E This bit is also optional, but allows\npyenv and plugins to change variables in your current shell, making\ncommands like \u003Ccode\u003Epyenv shell\u003C\u002Fcode\u003E possible. The sh dispatcher doesn&#39;t do\nanything crazy like override \u003Ccode\u003Ecd\u003C\u002Fcode\u003E or hack your shell prompt, but if\nfor some reason you need \u003Ccode\u003Epyenv\u003C\u002Fcode\u003E to be a real script rather than a\nshell function, you can safely skip it.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003ETo see exactly what happens under the hood for yourself, run \u003Ccode\u003Epyenv init -\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Ch3 id=\"uninstalling-python-versions\"\u003EUninstalling Python Versions\u003C\u002Fh3\u003E\n\u003Cp\u003EAs time goes on, you will accumulate Python versions in your\n\u003Ccode\u003E$(pyenv root)\u002Fversions\u003C\u002Fcode\u003E directory.\u003C\u002Fp\u003E\n\u003Cp\u003ETo remove old Python versions, \u003Ccode\u003Epyenv uninstall\u003C\u002Fcode\u003E command to automate\nthe removal process.\u003C\u002Fp\u003E\n\u003Cp\u003EAlternatively, simply \u003Ccode\u003Erm -rf\u003C\u002Fcode\u003E the directory of the version you want\nto remove. You can find the directory of a particular Python version\nwith the \u003Ccode\u003Epyenv prefix\u003C\u002Fcode\u003E command, e.g. \u003Ccode\u003Epyenv prefix 2.6.8\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"command-reference\"\u003ECommand Reference\u003C\u002Fh2\u003E\n\u003Cp\u003ESee \u003Ca href=\"COMMANDS.md\"\u003ECOMMANDS.md\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch2 id=\"environment-variables\"\u003EEnvironment variables\u003C\u002Fh2\u003E\n\u003Cp\u003EYou can affect how pyenv operates with the following settings:\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003Ename\u003C\u002Fth\u003E\n\u003Cth\u003Edefault\u003C\u002Fth\u003E\n\u003Cth\u003Edescription\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003EPYENV_VERSION\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003ESpecifies the Python version to be used.\u003Cbr\u003EAlso see \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fblob\u002Fmaster\u002FCOMMANDS.md#pyenv-shell\"\u003E\u003Ccode\u003Epyenv shell\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003EPYENV_ROOT\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ccode\u003E~\u002F.pyenv\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003EDefines the directory under which Python versions and shims reside.\u003Cbr\u003EAlso see \u003Ccode\u003Epyenv root\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003EPYENV_DEBUG\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003EOutputs debug information.\u003Cbr\u003EAlso as: \u003Ccode\u003Epyenv --debug &lt;subcommand&gt;\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003EPYENV_HOOK_PATH\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fwiki\u002FAuthoring-plugins#pyenv-hooks\"\u003E\u003Cem\u003Esee wiki\u003C\u002Fem\u003E\u003C\u002Fa\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003EColon-separated list of paths searched for pyenv hooks.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003EPYENV_DIR\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ccode\u003E$PWD\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003EDirectory to start searching for \u003Ccode\u003E.python-version\u003C\u002Fcode\u003E files.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003EPYTHON_BUILD_ARIA2_OPTS\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003EUsed to pass additional parameters to \u003Ca href=\"https:\u002F\u002Faria2.github.io\u002F\"\u003E\u003Ccode\u003Earia2\u003C\u002Fcode\u003E\u003C\u002Fa\u003E.\u003Cbr\u003Eif \u003Ccode\u003Earia2c\u003C\u002Fcode\u003E binary is available on PATH, pyenv use \u003Ccode\u003Earia2c\u003C\u002Fcode\u003E instead of \u003Ccode\u003Ecurl\u003C\u002Fcode\u003E or \u003Ccode\u003Ewget\u003C\u002Fcode\u003E to download the Python Source code. If you have an unstable internet connection, you can use this variable to instruct \u003Ccode\u003Earia2\u003C\u002Fcode\u003E to accelerate the download.\u003Cbr\u003EIn most cases, you will only need to use \u003Ccode\u003E-x 10 -k 1M\u003C\u002Fcode\u003E as value to \u003Ccode\u003EPYTHON_BUILD_ARIA2_OPTS\u003C\u002Fcode\u003E environment variable\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Ch2 id=\"development\"\u003EDevelopment\u003C\u002Fh2\u003E\n\u003Cp\u003EThe pyenv source code is \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\"\u003Ehosted on\nGitHub\u003C\u002Fa\u003E.  It&#39;s clean, modular,\nand easy to understand, even if you&#39;re not a shell hacker.\u003C\u002Fp\u003E\n\u003Cp\u003ETests are executed using \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fsstephenson\u002Fbats\"\u003EBats\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E$ bats test\n$ bats\u002Ftest\u002F&lt;file&gt;.bats\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EPlease feel free to submit pull requests and file bugs on the \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpyenv\u002Fpyenv\u002Fissues\"\u003Eissue\ntracker\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Ch3 id=\"version-history\"\u003EVersion History\u003C\u002Fh3\u003E\n\u003Cp\u003ESee \u003Ca href=\"CHANGELOG.md\"\u003ECHANGELOG.md\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Ch3 id=\"license\"\u003ELicense\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ca href=\"LICENSE\"\u003EThe MIT License\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n"}],fetch:{},mutations:void 0});