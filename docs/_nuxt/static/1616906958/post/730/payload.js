__NUXT_JSONP__("/post/730", {data:[{article:"\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fblog.cdn.thinkmoon.cn\u002Fblog\u002Ftypecho\u002F2020-01-18T14:20:17.png\" alt=\"5. Longest Palindromic Substring最长回文子串\"\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"解法1：中心拓展算法\"\u003E解法1：中心拓展算法\u003C\u002Fh2\u003E\n\u003Ch3 id=\"思路\"\u003E思路\u003C\u002Fh3\u003E\n\u003Cp\u003E首先，我们知道回文串一定是对称的，所以我们可以选择一个对称中心，进行左右扩展，判断左右字符是否相等即可。\n由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n+n-1 个中心。\u003C\u002Fp\u003E\n\u003Ch3 id=\"实现代码\"\u003E实现代码\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-python\"\u003Eclass Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n        n = len(s)\n        Max,sub = 0,s[0:1]\n        for i in range(n):\n            tmp = self.searchPalindrome(i-1,i+1,s)\n            if len(tmp) &gt; Max:\n                Max = len(tmp)\n                sub = tmp\n            tmp = self.searchPalindrome(i-1,i,s)\n            if len(tmp) &gt; Max:\n                Max = len(tmp)\n                sub = tmp    \n        return sub\n    \n    def searchPalindrome(self, left: int, right: int, s: str) -&gt; int:\n        sub = &quot;&quot;\n        while left != -1 and right != len(s):\n            if s[left] == s[right]:\n                sub = s[left:right+1]\n                left-=1\n                right+=1\n            else : break\n        return sub\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"马拉车算法\"\u003E马拉车算法\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-python\"\u003Eclass Solution:\n    # Manacher 算法\n    def longestPalindrome(self, s: str) -&gt; str:\n        # 特判 \n        if len(s) &lt; 2 or s == s[::-1]:\n            return s\n\n        # 得到预处理字符串\n        t = &quot;#&quot; + &quot;#&quot;.join(s) + &quot;#&quot;\n\n        # 新字符串的长度\n        t_len = len(t)\n\n        # 数组 p 记录了扫描过的回文子串的信息\n        p = [0]*t_len\n\n        # 双指针，它们是一一对应的，须同时更新\n        max_right = 0\n        center = 0\n\n        # 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度\n        max_len = 1\n        # 原始字符串的最长回文子串的起始位置，与 max_len 必须同时更新\n        start = 1\n\n        for i in range(t_len):\n            if i &lt; max_right:\n                mirror = 2 * center - i\n                # 这一行代码是 Manacher 算法的关键所在，要结合图形来理解\n                p[i] = min(max_right - i, p[mirror])\n\n            # 下一次尝试扩散的左右起点，能扩散的步数直接加到 p[i] 中\n            left = i - (1 + p[i])\n            right = i + (1 + p[i])\n\n            # left &gt;= 0 and right &lt; t_len 保证不越界\n            # t[left] == t[right] 表示可以扩散 1 次\n            while left &gt;= 0 and right &lt; t_len and t[left] == t[right]:\n                p[i] += 1\n                left -= 1\n                right += 1\n\n            # 根据 max_right 的定义，它是遍历过的 i 的 i + p[i] 的最大者\n            # 如果 max_right 的值越大，进入上面 i &lt; max_right 的判断的可能性就越大，这样就可以重复利用之前判断过的回文信息了\n            if i + p[i] &gt; max_right:\n                # max_right 和 center 需要同时更新\n                max_right = i + p[i]\n                center = i\n\n            if p[i] &gt; max_len:\n                # 记录最长回文子串的长度和相应它在原始字符串中的起点\n                max_len = p[i]\n                start = (i - max_len) \u002F\u002F 2\n        return s[start: start + max_len]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"成果\"\u003E成果\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fblog.cdn.thinkmoon.cn\u002Fblog\u002Ftypecho\u002F2020-01-19T15:04:32.png\" alt=\"2020-01-19T15:04:32.png\"\u003E\u003C\u002Fp\u003E\n"}],fetch:{},mutations:void 0});