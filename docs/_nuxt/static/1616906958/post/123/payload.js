__NUXT_JSONP__("/post/123", {data:[{article:"\u003Cblockquote\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E首先，为什么我们需要这个？\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E因为微信小程序虽然可以可以绘制svg图片，但是在真机调试的时候却渲染不出来。所以我们需要一个工具(可以将svg转成微信小程序支持的canvas并绘制出来)。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E我使用的是touch-wx + vs code 开发。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E现已启用该开发模式.因为Ubuntu下经常编译不完整\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"touch-wx-是什么？\"\u003ETouch WX 是什么？\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fblog.cdn.thinkmoon.cn\u002FTIM%E6%88%AA%E5%9B%BE20180620111841.png\" alt=\"Touch WX\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETouch WX是一套完全免费的微信小程序开发框架，包含丰富的UI控件用于官方组件的补充。与Touch UI开发方式很相似，也是通过VSCode编辑器+插件的方式开发，经过编译后输出小程序代码。\n与其他小程序框架最主要的区别在于：Touch UI完全是基于小程序官方的自定义组件机制实现，输出的是小程序原始代码，而不是输出开发者完全无法阅读的编译代码。这样当遇到问题时，开发者可以很方便的定位问题所在，还可以基于输出的原始代码继续开发。\n当你用Touch UI开发了H5应用，可以直接导入到Touch WX进行转换，稍作调整就能生成小程序。反之也同样，当你Touch WX开发了微信小程序，可以导出为Touch UI工程来生成H5应用。\u003C\u002Fp\u003E\n\u003Ch2 id=\"touch-wx-的特点\"\u003ETouch WX 的特点\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fblog.cdn.thinkmoon.cn\u002FTIM%E6%88%AA%E5%9B%BE20180620111451.png\" alt=\"Touch WX\"\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"我的理解\"\u003E我的理解\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003ETouch WX 就是一个可以将特定的nodejs项目编译成微信小程序项目的框架\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"touch-wx更多操作\"\u003ETouch WX更多操作\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E更多操作见\u003Ca href=\"http:\u002F\u002Fwww.touchui.io\u002Ftouchui_doc_wx\u002F\"\u003Ehttp:\u002F\u002Fwww.touchui.io\u002Ftouchui_doc_wx\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E推荐大家看一下，或许会打开新世界的大门哦！\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E接下来，我默认你已经看了Touch WX的文档，并且拥有一定的nodejs基础\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"开始流程\"\u003E开始流程\u003C\u002Fh2\u003E\n\u003Ch3 id=\"安装parse-svg-path\"\u003E安装parse-svg-path\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Ccode\u003Enpm install parse-svg-path --save\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"引入parse-svg-path\"\u003E引入parse-svg-path\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Ccode\u003Evar parse = require(&#39;parse-svg-path&#39;)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"使用parse-svg-path\"\u003E使用parse-svg-path\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Ccode\u003Eparse(d)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Ccode\u003Ed\u003C\u002Fcode\u003E为svg中的path值\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E不了解svg？\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E请转\u003Ccode\u003Ehttp:\u002F\u002Fwww.w3school.com.cn\u002Fsvg\u002Fsvg_intro.asp\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"如何获得path值？\"\u003E如何获得path值？\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-JavaScript\"\u003Evar options = {\n            url:&quot;svg的URL&quot;,\n            success:function(res){\n              const ctx = wx.createCanvasContext(&#39;myCanvas&#39;)\n              ctx.setFillStyle(&#39;black&#39;)\n              var match = res.data.match(\u002Fd=&quot;(.*?)&quot;\u002F);\n              var d = match[1];\n              console.log(d);\n            }\n    }\n    wx.request(options); \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E上图中d就是path值，我这里使用的是正则表达式查找，而且只有一个path，如不一样，请自行modify\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"解析后的值\"\u003E解析后的值\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-JavaScript\"\u003Econsole.log(parse(d));\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fblog.cdn.thinkmoon.cn\u002FTIM%E6%88%AA%E5%9B%BE20180620113452.png\" alt=\"效果展示\"\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E解析之后是一系列的操作序列数组\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"绘制图形\"\u003E绘制图形\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E根据一系列的操作，找到对应的微信小程序绘制API，进行绘制\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-JavaScript\"\u003Eparse(d).forEach(function (element){\n                if(element[0] == &quot;M&quot;){\n                  ctx.moveTo(element[1], element[2])\n                }else if(element[0] == &quot;Q&quot;){\n                  ctx.quadraticCurveTo(element[1], element[2], element[3], element[4])\n                }\n              });\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E因为我这里只有M，Q操作所以我只用了两个API，可根据实际情况自行拓展\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"实例代码\"\u003E实例代码\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003Edisplay.wx\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-JavaScript\"\u003E&lt;template&gt;\n  &lt;view class=&#39;page&#39;&gt;\n    &lt;canvas canvas-id=&quot;myCanvas&quot; style=&quot;border: 1px solid;&quot;\u002F&gt;\n    &lt;!-- &lt;view class=&#39;content&#39;&gt;&lt;text class=&quot;zhuan&quot; style=&quot;font-size:{{fontSize}}pt&quot;&gt;{{display}}&lt;\u002Ftext&gt; --&gt;\n  &lt;!-- &lt;\u002Fview&gt; --&gt;\n&lt;\u002Fview&gt;\n&lt;\u002Ftemplate&gt;\n\n&lt;script&gt;\nvar parse = require(&#39;parse-svg-path&#39;)\nexport default {\n  config: {\n    navigationBarTitleText: &#39;效果展示&#39;\n  },\n  data: {},\n  onLoad: function (options) {\n    var str = options.display;\n    if(str != null){\n      try {\n        str=decodeURI(str);\n        wx.setStorageSync(&#39;display&#39;, str)\n        console.log(&quot;接受到的str：&quot;+str);\n      } catch (e) {\n        console.log(&quot;设置diaplay值错误&quot;)\n      }\n    }  \n  },\n\n  \u002F**\n   * 生命周期函数--监听页面初次渲染完成\n   *\u002F\n  onReady: function () {\n  \n  },\n  saveTemp(){\n    console.log(&quot;fdsaf&quot;);\n    wx.canvasToTempFilePath({\n      canvasId: &#39;myCanvas&#39;,\n      fail: function(res) {\n        console.log(res);\n      },\n      success: function(res) {\n        console.log(res.tempFilePath)\n        setTimeout(function(){wx.saveImageToPhotosAlbum({\n          filePath:res.tempFilePath,\n          fail:function(res){\n            console.log(res);\n          }\n          \n          });},5000)\n        \n      },\n       \n    })\n  },\n  \u002F**\n   * 生命周期函数--监听页面显示\n   *\u002F\n  onShow: function () {\n    var that = this;\n    \n    var options = {\n            url:&quot;http:\u002F\u002Fmp.thinkmoon.cn:39999?str=我&amp;site=0&quot;,\n            success:function(res){\n              const ctx = wx.createCanvasContext(&#39;myCanvas&#39;)\n              ctx.setFillStyle(&#39;black&#39;)\n              var match = res.data.match(\u002Fd=&quot;(.*?)&quot;\u002F);\n              var d = match[1];\n              console.log(parse(d))\n              parse(d).forEach(function (element){\n                if(element[0] == &quot;M&quot;){\n                  ctx.moveTo(element[1], element[2])\n                }else if(element[0] == &quot;Q&quot;){\n                  ctx.quadraticCurveTo(element[1], element[2], element[3], element[4])\n                }\n              });\n              ctx.fill();\n              ctx.draw(false,()=&gt;{setTimeout(() =&gt; {that.saveTemp()},5000);});\n            }\n    }\n    wx.request(options); \n    \u002F\u002F wx.getStorage({\n    \u002F\u002F   key: &#39;display&#39;,\n    \u002F\u002F   success: function (res) {\n    \u002F\u002F     console.log(&quot;display的值为&quot; + res.data)\n    \u002F\u002F     that.setData({\n    \u002F\u002F       display: res.data,\n    \u002F\u002F       fontSize: wx.getStorageSync(&#39;pt&#39;)\n    \u002F\u002F     })\n    \u002F\u002F   }\n    \u002F\u002F })\n  },\n\n  \u002F**\n   * 生命周期函数--监听页面隐藏\n   *\u002F\n  onHide: function () {\n  \n  },\n\n  \u002F**\n   * 生命周期函数--监听页面卸载\n   *\u002F\n  onUnload: function () {\n  \n  },\n\n  \u002F**\n   * 页面相关事件处理函数--监听用户下拉动作\n   *\u002F\n  onPullDownRefresh: function () {\n  \n  },\n\n  \u002F**\n   * 页面上拉触底事件的处理函数\n   *\u002F\n  onReachBottom: function () {\n  \n  },\n\n  \u002F**\n   * 用户点击右上角分享\n   *\u002F\n  onShareAppMessage: function () {\n    var str = this.data.display;\n    var pages = getCurrentPages()    \u002F\u002F获取加载的页面\n    var currentPage = pages[pages.length - 1]    \u002F\u002F获取当前页面的对象\n    var url = currentPage.route\n    var inUrl = url + &quot;?display=&quot; + encodeURI(str);\n    console.log(&quot;分享的链接为&quot;+inUrl);\n    return {\n      title: &#39;您的好友给您分享了一段篆文&#39;,\n      path: inUrl,\n      success: function (res) {\n        \u002F\u002F 转发成功\n      },\n      fail: function (res) {\n        \u002F\u002F 转发失败\n      }\n    }\n  }\n}\n&lt;\u002Fscript&gt;\n\n&lt;style lang=&quot;less&quot;&gt;\n.content{\n  text-align: center;\n}\ncanvas{\n  width: 256px;\n  height: 256px;\n}\n\n&lt;\u002Fstyle&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"后记\"\u003E后记\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E我这个实例本来是将svg转canvas绘制出来，再转图片，下载到本地的。但是因为draw()函数是异步的所以需要等待。才可以下载成功，否则会出现一片黑的情况，总之感觉各种麻烦。再加上画布的大小难以设置。后我还是选择在服务端生成图片再转发过来。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"参考文献\"\u003E参考文献\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fwww.w3school.com.cn\u002Fsvg\u002Fsvg_intro.asp\"\u003ESVG简介\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fwww.touchui.io\u002Ftouchui_doc_wx\u002F\"\u003ETouch WX开发文档\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdevelopers.weixin.qq.com\u002Fminiprogram\u002Fdev\u002Fapi\u002Fcanvas\u002Fintro.html\"\u003E微信开发文档Canvas\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"}],fetch:{},mutations:void 0});