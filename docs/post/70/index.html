<!doctype html>
<html data-n-head-ssr lang="zh-CN" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22zh-CN%22%7D%7D">
<head>
  <title>毕业设计思路篇(一)之交通图的构建</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta data-n-head="ssr" data-hid="keywords" name="keywords" content="thinkmoon,醉月思,指尖魔法屋"><meta data-n-head="ssr" data-hid="description" name="description" content="总结与记录是两个极其优秀的学习习惯！"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="/highlight/atom-one-dark.min.css"><link data-n-head="ssr" rel="stylesheet" href="/style.css"><script data-n-head="ssr" src="/highlight/highlight.min.js"></script><link rel="preload" href="/_nuxt/e4b7d96.js" as="script"><link rel="preload" href="/_nuxt/fc6b942.js" as="script"><link rel="preload" href="/_nuxt/css/edb8de7.css" as="style"><link rel="preload" href="/_nuxt/623b5d2.js" as="script"><link rel="preload" href="/_nuxt/746647a.js" as="script"><link rel="stylesheet" href="/_nuxt/css/edb8de7.css"><link rel="preload" href="/_nuxt/static/1620744781/post/70/state.js" as="script"><link rel="preload" href="/_nuxt/static/1620744781/post/70/payload.js" as="script"><link rel="preload" href="/_nuxt/static/1620744781/manifest.js" as="script">
</head>
<body>
<div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><div class="container"><div class="article-content"><h1 class="article-title">
      毕业设计思路篇(一)之交通图的构建
    </h1> <div><p><img src="https://www.thinkmoon.cn/usr/uploads/2019/01/1381127992.png" alt="2019-01-13 10-50-54屏幕截图.png"></p>
<h2 id="1-导入道路地图">1. 导入道路地图</h2>
<p>道路地图来自网络数据,已预处理为xml格式。</p>
<pre><code class="language-xml">&lt;?xml version='1.0' encoding='UTF-8'?>
&lt;Roads>
  &lt;road m_ID="71283896--1" len="620.98">
    &lt;from lon="113.9205606" lat="22.9317667" id="848388981"/>
    &lt;to lon="113.9260573" lat="22.9341232" id="2522072722"/>
  &lt;/road>
  &lt;road m_ID="553852656--2" len="322.34">
    &lt;from lon="113.9529339" lat="22.9448978" id="5345735265"/>
    &lt;to lon="113.9516926" lat="22.9475618" id="5345735267"/>
  &lt;/road>
&lt;/Roads>
</code></pre>
<blockquote>
<p>解析：一个road节点代表一条道路，len代表道路抽象长度，from，to子节点分别表示道路两端端点。</p>
</blockquote>
<h2 id="2-解析道路数据">2. 解析道路数据</h2>
<h3 id="a-构建交通图">a. 构建交通图</h3>
<blockquote>
<p>赋值道路端点.</p>
</blockquote>
<pre><code class="language-C++">/**
*  路口类，记录着该路口的点坐标，以及其相连的方向道路节点组
 *               |           |
 *               |     |     |
 *               |  1     2  |
 *               |     |     |
 *        --------           --------
 *           3                  5
 *        - - - -            - - - -
 *           4                  6
 *        --------           --------
 *               |     |     |
 *               |  7     8  |
 *               |     |     |
 *               |           |
 *    如上图(1,2), (3,4), (5,6), (7,8)在同一个方向,我将其称为四组方向道路节点Node.
 *    其中,Node.inRoadID=1, Node.outRoadID=2;
 *         Node.inRoadID=4, Node.outRoadID=3;
 *         ...
 *         根据车辆靠右行原则以此类推.
*/
class CrossRoad {
public:
    CrossRoad(float fLon,float fLat) : m_fLat(fLat),m_fLon(fLon){};
    /**
     * 重载运算符 （==） 判断两个路口是否为同一个
     */
    bool operator==(CrossRoad &crossRoad);
    /**
     * 添加道路节点ID
     * @param in 入度
     * @param out 出度
     * @param atan2 该点与方向道路的atan2值
     */
    void addNode(int in,int out,double atan2);
public:
    //唯一标示符
    int m_nID;
    //经纬度的定义
    float m_fLon, m_fLat;
    vector&lt;Node> JunctionRoad;
    //该路口的交通灯
    TrafficLight m_CTrafficLight_Light;
};
</code></pre>
<p><code>CrossRoad A,B</code></p>
<blockquote>
<p>添加道路到交通图</p>
</blockquote>
<pre><code class="language-C++">void addRoad(Graph &Map_Graph, CrossRoad A, CrossRoad B, double length) {
    // 初始化A，B路口的索引位置为-1
    int CrossRoadSiteB = -1, CrossRoadSiteA = -1;
    auto CrossRoadNum = Map_Graph.m_CrossRoad_v.size(), RoadNum = Map_Graph.m_Road_v.size();
    //循环判断是否有重合点
    for (int i = 0; i &lt; CrossRoadNum; i++) {
        if (Map_Graph.m_CrossRoad_v[i] == A) {
            CrossRoadSiteA = i;
        }
        if (Map_Graph.m_CrossRoad_v[i] == B) {
            CrossRoadSiteB = i;
        }
    }
    //如果不存在与A点重合的路口,添加路口，保存路口索引
    if (CrossRoadSiteA == -1) {
        Map_Graph.m_CrossRoad_v.push_back(A);
        CrossRoadSiteA = CrossRoadNum++;
        Map_Graph.m_CrossRoad_v[CrossRoadSiteA].m_nID = CrossRoadSiteA;
    }
    if (CrossRoadSiteB == -1) {
        Map_Graph.m_CrossRoad_v.push_back(B);
        CrossRoadSiteB = CrossRoadNum++;
        Map_Graph.m_CrossRoad_v[CrossRoadSiteB].m_nID = CrossRoadSiteB;
    }
    int RoadSiteA = RoadNum, RoadSiteB = RoadNum + 1;
    // 确定A，B路的site，加入模型图
    Road roadA(RoadSiteA, CrossRoadSiteA, CrossRoadSiteB, length);
    Map_Graph.m_Road_v.push_back(roadA);
    Road roadB(RoadSiteB, CrossRoadSiteB, CrossRoadSiteA, length);
    Map_Graph.m_Road_v.push_back(roadB);
    // 对接A，B路口节点数据
    Map_Graph.m_CrossRoad_v[CrossRoadSiteA].addNode(RoadSiteA, RoadSiteB,
                                                    atan2((B.m_fLat - A.m_fLat), (B.m_fLon - A.m_fLon)));
    Map_Graph.m_CrossRoad_v[CrossRoadSiteB].addNode(RoadSiteB, RoadSiteA,atan2((A.m_fLat - B.m_fLat), (A.m_fLon - B.m_fLon)));
}
</code></pre>
<blockquote>
<p>解析的结果如下<br><a href="https://www.thinkmoon.cn/usr/uploads/2019/01/2044047466.txt">road.txt</a><br><a href="https://www.thinkmoon.cn/usr/uploads/2019/01/4058503811.txt">RoadTable.txt</a></p>
</blockquote>
</div></div></div></div></div></div><script defer src="/_nuxt/static/1620744781/post/70/state.js"></script><script src="/_nuxt/e4b7d96.js" defer></script><script src="/_nuxt/fc6b942.js" defer></script><script src="/_nuxt/623b5d2.js" defer></script><script src="/_nuxt/746647a.js" defer></script>
</body>
<script defer>hljs.highlightAll()</script>
</html>
