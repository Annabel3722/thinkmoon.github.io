<!doctype html>
<html data-n-head-ssr lang="zh-CN" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22zh-CN%22%7D%7D">
<head>
  <title>浏览器机制之js事件循环</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta data-n-head="ssr" data-hid="keywords" name="keywords" content="thinkmoon,醉月思,指尖魔法屋"><meta data-n-head="ssr" data-hid="description" name="description" content="总结与记录是两个极其优秀的学习习惯！"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="/highlight/atom-one-dark.min.css"><link data-n-head="ssr" rel="stylesheet" href="/style.css"><script data-n-head="ssr" src="/highlight/highlight.min.js"></script><link rel="preload" href="/_nuxt/e4b7d96.js" as="script"><link rel="preload" href="/_nuxt/fc6b942.js" as="script"><link rel="preload" href="/_nuxt/css/edb8de7.css" as="style"><link rel="preload" href="/_nuxt/623b5d2.js" as="script"><link rel="preload" href="/_nuxt/746647a.js" as="script"><link rel="stylesheet" href="/_nuxt/css/edb8de7.css"><link rel="preload" href="/_nuxt/static/1620746793/post/907/state.js" as="script"><link rel="preload" href="/_nuxt/static/1620746793/post/907/payload.js" as="script"><link rel="preload" href="/_nuxt/static/1620746793/manifest.js" as="script">
</head>
<body>
<div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><div class="container"><div class="article-content"><h1 class="article-title">
      浏览器机制之js事件循环
    </h1> <div><p><img src="http://blog.cdn.thinkmoon.cn/blog/typecho/2020-08-24T14:58:17.png" alt="2020-08-24T14:58:17.png"></p>
<h2 id="引言">引言</h2>
<p>总所周知，js是单线程的。单线程意味着，js代码在执行的任何时候，都只有一个主线程来处理所有的任务（为了避免多线程可能产生的诸多问题，直接阉割多线程的可能性）。然而，随着硬件设备的快速发展，网页要做的事情会变得越来越多。人们慢慢意识到，不能让单线程限制了js的效率，然后web worker便应运而生。</p>
<h2 id="栈，堆，队列">栈，堆，队列</h2>
<p><img src="http://blog.cdn.thinkmoon.cn/blog/typecho/2020-08-24T14:58:35.png" alt="2020-08-24T14:58:35.png"></p>
<p>基本数据结构知识略过~</p>
<p>讲讲它们在js语言层面的应用。</p>
<p>执行栈：函数调用形成了一个由若干帧（执行上下文）组成的栈。</p>
<p>消息队列：一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。</p>
<blockquote>
<p>在 事件循环 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。<br>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p>
</blockquote>
<h2 id="任务队列">任务队列</h2>
<p>在js事件循环机制中，存在多种任务队列，它们可分为宏任务（macro-task）和微任务（micro-task）两种。</p>
<ul>
<li>宏任务包括：setTimeout、setInterval、I/O、UI rendering</li>
<li>微任务包括：process.nextTick、Promise、Object.observe（已废弃）、MutationObserver（html5新特性）</li>
</ul>
<h2 id="事件循环">事件循环</h2>
<p><img src="http://blog.cdn.thinkmoon.cn/blog/typecho/2020-08-24T14:58:17.png" alt="2020-08-24T14:58:17.png"></p>
<p>如上图所示，事件循环就是在主线程清空执行上下文栈后空闲之时，先去微任务队列中读取待执行程序，并装载到主线程中。如果没有内容（各类微任务队列都清空），则将去宏任务队列中寻找。如此往复，周而复始，直至结束。</p>
<h2 id="参考文档">参考文档</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">并发模型与事件循环-MDN</a><br><a href="https://zhuanlan.zhihu.com/p/33058983">详解JavaScript中的Event Loop（事件循环）机制-知乎</a><br><a href="https://juejin.im/post/6844903638238756878">JS事件循环机制（event loop）之宏任务/微任务-掘金</a><br><a href="https://juejin.im/post/6844903634816204813">JavaScript 事件循环机制-掘金</a></p>
</div></div></div></div></div></div><script defer src="/_nuxt/static/1620746793/post/907/state.js"></script><script src="/_nuxt/e4b7d96.js" defer></script><script src="/_nuxt/fc6b942.js" defer></script><script src="/_nuxt/623b5d2.js" defer></script><script src="/_nuxt/746647a.js" defer></script>
</body>
<script defer>hljs.highlightAll()</script>
</html>
