<!doctype html>
<html data-n-head-ssr lang="zh-CN" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22zh-CN%22%7D%7D">
<head>
  <title>在微信小程序里使用async/await异步API及浅谈各种异步</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta data-n-head="ssr" data-hid="description" name="description" content="指尖魔法屋"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="/highlight/atom-one-dark.min.css"><link data-n-head="ssr" rel="stylesheet" href="/style.css"><script data-n-head="ssr" src="/highlight/highlight.min.js"></script><link rel="preload" href="/_nuxt/b0f8911.js" as="script"><link rel="preload" href="/_nuxt/fc6b942.js" as="script"><link rel="preload" href="/_nuxt/css/a5b6cb0.css" as="style"><link rel="preload" href="/_nuxt/a1b9b3d.js" as="script"><link rel="preload" href="/_nuxt/02b3e78.js" as="script"><link rel="stylesheet" href="/_nuxt/css/a5b6cb0.css"><link rel="preload" href="/_nuxt/static/1619942794/post/219/state.js" as="script"><link rel="preload" href="/_nuxt/static/1619942794/post/219/payload.js" as="script"><link rel="preload" href="/_nuxt/static/1619942794/manifest.js" as="script">
</head>
<body>
<div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><div class="container"><div class="article-content"><h1 class="article-title">在微信小程序里使用async/await异步API及浅谈各种异步</h1> <div><blockquote>
<p>想达到本文效果，需使用wepy框架。不了解wepy？转<a href="https://tencent.github.io/wepy/index.html">https://tencent.github.io/wepy/index.html</a></p>
</blockquote>
<h2 id="什么是asyncawait">什么是async/await?</h2>
<blockquote>
<p>在最新的ES7（ES2017）中提出的前端异步特性：async、await。<br>async顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成。也就是我们平常所说的异步等待。不过需注意<code>await只能在async函数中使用</code>。</p>
</blockquote>
<h2 id="为什么需要asyncawait">为什么需要async/await?</h2>
<p>在async/await之前，我们有三种方式写异步代码</p>
<h3 id="1-嵌套回调">1. 嵌套回调</h3>
<p>其中思想就是,a函数执行完了得到的结果后在执行b。<br>形如</p>
<pre><code class="language-javascript">wx.getSetting({
      success(res) {
        console.log(res.authSetting['scope.userLocation']);
        if (!res.authSetting['scope.userLocation']) {
          wx.authorize({
            scope: 'scope.userLocation',
            fail(res) {
              Toast('无法获取位置,采用默认排序');
            }
          });
        } else {
          wx.getLocation({
            type: 'wgs84',
            success(res) {
              _this.setData({ location: res });
              console.log('您的位置信息:', res);
            },
            fail() {
              Toast('无法获取位置,采用默认排序');
            }
          });
        }
      }
    });
</code></pre>
<blockquote>
<p>上面的代码你不用看，就会感觉。这啥东西？乱七八糟的。这就是嵌套回调。很不巧，原生微信小程序开发就是这样的。</p>
</blockquote>
<h3 id="2-以promise为主的链式回调">2. 以Promise为主的链式回调</h3>
<blockquote>
<p>所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。形如</p>
</blockquote>
<pre><code class="language-javascript">var p1 = new Promise((resolve, reject) => {
 setTimeout(resolve, 1000, 'done');
 })
p1.then(data=>{
 console.log(data); // done
})
</code></pre>
<p>如果你的函数够多的话，那么就会一直then()下去。</p>
<blockquote>
<p>为了优雅，Promise提供了一个方法<code>Promise.all([p1,p2,p3])</code> ，用于将多个Promise实例，包装成一个新的Promise实例。接收的参数是一个数组,p1、p2、p3都是Promise对象<br>分两种情况：</p>
</blockquote>
<ol>
<li>p1、p2、p3的状态都是resolve的时候，Promise.all的状态才会变成resolve；</li>
<li>只要p1、p2、p3中有一个的状态为reject，那么Promise.all的状态就会变成reject；<br>所以我们可以用Promise.all()来解决多个异步依赖调用。</li>
</ol>
<h3 id="3-使用generators">3. 使用Generators</h3>
<pre><code class="language-javascript">function *main() {
    var x = yield 1;
    var y = yield x;
    var z = yield (y * 2);
}
</code></pre>
<blockquote>
<p>上面代码中的每一条语句都会按顺序一个一个地执行。Yield关键字标明了代码中被阻塞的点（只能被generator函数自己阻塞，外部代码不能阻塞generator函数的执行），但是不会改变*main()函数中代码的执行顺序。这段代码很简单！</p>
</blockquote>
<p>但是，这三种写起来都还是不够优雅，ES7做了优化改进，async/await应运而生，async/await相比较Promise 对象then 函数的嵌套，与 Generator 执行的繁琐(需要借助co才能自动执行，否则得手动调用next())， Async/Await 可以让你轻松写出同步风格的代码同时又拥有异步机制，更加简洁，逻辑更加清晰。</p>
<blockquote>
<p>示例</p>
</blockquote>
<pre><code class="language-javascript">async a(){};
const b = await a();
</code></pre>
<h2 id="这样做的好处？">这样做的好处？</h2>
<blockquote>
<p>唔，你不觉得一个优雅的代码就该是这样吗？好吧，其实这样更容易符合我们平常的思维逻辑</p>
</blockquote>
<h2 id="回到本文的题目">回到本文的题目</h2>
<blockquote>
<p>在wepy1.4.1以后的版本（之前的版本都是默认开启的），默认不支持async/await，需要用户手动加入，方法如下：</p>
</blockquote>
<h3 id="进入项目根目录，安装runtime包">进入项目根目录，安装runtime包</h3>
<pre><code>npm install wepy-async-function --save
</code></pre>
<h3 id="修改wepyconfigjs加入runtime配置">修改wepy.config.js加入runtime配置</h3>
<pre><code>        babel: {
            "presets": [
                "env"
            ],
            "plugins": [
                "transform-export-extensions",
                "syntax-export-extensions"
            ]
        }
</code></pre>
<h3 id="在appwpy中引入引入runtime包">在app.wpy中引入引入runtime包</h3>
<pre><code>import 'wepy-async-function'; 
</code></pre>
<h3 id="在appwpy中使api-promise化">在app.wpy中使API promise化</h3>
<blockquote>
<p>重写构造函数，使其支持async/await。</p>
</blockquote>
<pre><code>export default class extends wepy.app {
    constructor () {
        super();
        this.use('promisify');
    }
}
</code></pre>
<h3 id="重启编译">重启编译</h3>
<pre><code>wepy build --no-cache
</code></pre>
<h2 id="使用示例">使用示例</h2>
<blockquote>
<p>在wepy框架官方文档中已说明，对所有的微信小程序都支持async/await操作。只需将形如<code>wx.getuserInfo</code>改写为<code>wepy.getuserInfo</code>即可</p>
</blockquote>
<pre><code>async userInfoAsync() {
    const _this = this;
    const data = await wepy.getSetting(); //获取设置数据
    if (data.authSetting['scope.userInfo']) { //判断是否有获取用户信息的权限
      await wepy.login(); //登录
      let data = await wepy.getUserInfo();//获取用户信息
      _this.userInfo = data.userInfo;//采用wepy框架修改过后的功能，支持直接赋值数据绑定
      _this.$apply(); //在async的函数中，必须主动执行`$apply()`来进行脏数据检查
    }
  }
async onShow() {
    this.userInfoAsync(); //调用async函数
  }
</code></pre>
<blockquote>
<p>以上代码实现了异步同步用户userInfo的功能</p>
</blockquote>
<p>参考文献:</p>
<ol>
<li><a href="https://www.jb51.net/article/103068.htm">使用Promise链式调用解决多个异步回调的问题</a></li>
<li><a href="https://blog.csdn.net/samt007/article/details/54647361">关于js的callback回调函数以及嵌套回调函数的执行过程理解</a></li>
<li><a href="https://www.cnblogs.com/jaxu/p/6592210.html">ES6 Generators并发</a></li>
<li><a href="https://www.cnblogs.com/leungUwah/p/7932912.html">ES7前端异步玩法：async/await理解</a></li>
<li><a href="https://segmentfault.com/a/1190000007535316?utm_source=tag-newest">理解 JavaScript 的 async/await</a></li>
<li><a href="https://segmentfault.com/a/1190000013292562?utm_source=channel-newest">Async/await学习</a></li>
<li><a href="https://www.jianshu.com/p/1e75bd387aa0">浅谈async/await</a></li>
<li><a href="https://github.com/Tencent/wepy/wiki/wepy%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8async-await">wepy项目中使用async await</a></li>
</ol>
</div></div></div></div></div></div><script defer src="/_nuxt/static/1619942794/post/219/state.js"></script><script src="/_nuxt/b0f8911.js" defer></script><script src="/_nuxt/fc6b942.js" defer></script><script src="/_nuxt/a1b9b3d.js" defer></script><script src="/_nuxt/02b3e78.js" defer></script>
</body>
<script defer>hljs.highlightAll()</script>
</html>
